/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunksetup_webpack"] = self["webpackChunksetup_webpack"] || []).push([["index"],{

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles.css":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles.css ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/getUrl.js */ \"./node_modules/css-loader/dist/runtime/getUrl.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);\n// Imports\n\n\n\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ./images/bg-mobile-light.jpg */ \"./src/images/bg-mobile-light.jpg\"), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(/*! ./images/bg-desktop-light.jpg */ \"./src/images/bg-desktop-light.jpg\"), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_2___ = new URL(/* asset import */ __webpack_require__(/*! ./images/bg-mobile-dark.jpg */ \"./src/images/bg-mobile-dark.jpg\"), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_3___ = new URL(/* asset import */ __webpack_require__(/*! ./images/bg-desktop-dark.jpg */ \"./src/images/bg-desktop-dark.jpg\"), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_4___ = new URL(/* asset import */ __webpack_require__(/*! ./images/icon-check.png */ \"./src/images/icon-check.png\"), __webpack_require__.b);\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);\nvar ___CSS_LOADER_URL_REPLACEMENT_2___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___);\nvar ___CSS_LOADER_URL_REPLACEMENT_3___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_3___);\nvar ___CSS_LOADER_URL_REPLACEMENT_4___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_4___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \":root {\\r\\n  --bg-body: hsl(0, 0%, 95%);\\r\\n  --bg-todo: hsl(0, 0%, 100%);\\r\\n  --text-active: hsl(244, 9%, 33%);\\r\\n  --state-color: hsl(240, 5%, 66%);\\r\\n  --state-hover-color: hsl(232, 11%, 39%);\\r\\n  --light-shadow: hsl(0, 0%, 86%);\\r\\n}\\r\\n\\r\\n/* color theme for dark mode system or OS */\\r\\n@media (prefers-color-scheme: dark) {\\r\\n  :root {\\r\\n    --bg-body: hsl(235, 21%, 11%);\\r\\n    --bg-todo: hsl(235, 24%, 19%);\\r\\n    --text-active: hsl(236, 9%, 61%);\\r\\n    --state-color: hsl(233, 14%, 35%);\\r\\n    --state-hover-color: hsl(0deg, 0%, 100%);\\r\\n    --light-shadow: hsla(235, 24%, 19%, 0.87);\\r\\n  }\\r\\n}\\r\\n\\r\\n/* set the root attribute color theme to light (switching manually) */\\r\\n[color-scheme='light'] {\\r\\n  --bg-body: hsl(0, 0%, 95%);\\r\\n  --bg-todo: hsl(0, 0%, 100%);\\r\\n  --text-active: hsl(244, 9%, 33%);\\r\\n  --state-color: hsl(240, 5%, 66%);\\r\\n  --state-hover-color: hsl(232, 11%, 39%);\\r\\n  --light-shadow: rgb(219, 219, 219);\\r\\n}\\r\\n\\r\\n/* set the root attribute color theme to dark (switching manually) */\\r\\n[color-scheme='dark'] {\\r\\n  --bg-body: hsl(235, 21%, 11%);\\r\\n  --bg-todo: hsl(235, 24%, 19%);\\r\\n  --text-active: hsl(236, 9%, 61%);\\r\\n  --state-color: hsl(233, 14%, 35%);\\r\\n  --state-hover-color: hsl(0deg, 0%, 100%);\\r\\n  --light-shadow: hsla(235, 24%, 19%, 0.87);\\r\\n}\\r\\n\\r\\n/* ----------- CSS RESET STYLES START ---------- */\\r\\n\\r\\n/* Box sizing rules */\\r\\n*,\\r\\n*::before,\\r\\n*::after {\\r\\n  box-sizing: border-box;\\r\\n}\\r\\n\\r\\n/* Remove default margin */\\r\\n* {\\r\\n  margin: 0;\\r\\n  padding: 0;\\r\\n  font-family: 'Josefin Sans', sans-serif;\\r\\n}\\r\\n\\r\\n/* Remove list styles on ul, ol elements with a list role, which suggests default styling will be removed */\\r\\nul,\\r\\nol {\\r\\n  list-style: none;\\r\\n}\\r\\n\\r\\n/* Set core root defaults */\\r\\nhtml {\\r\\n  scroll-behavior: smooth;\\r\\n}\\r\\n\\r\\n/* Set core body defaults */\\r\\nbody {\\r\\n  min-height: 100vh;\\r\\n  text-rendering: optimizeSpeed;\\r\\n  line-height: 1.5;\\r\\n  font-size: 16px;\\r\\n  background-color: var(--bg-body);\\r\\n}\\r\\n\\r\\n@media screen and (min-width: 40em) {\\r\\n  body {\\r\\n    font-size: 18px;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* A elements that don't have a class get default styles */\\r\\na:not([class]) {\\r\\n  text-decoration-skip-ink: auto;\\r\\n}\\r\\n\\r\\n/* Make images easier to work with */\\r\\nimg,\\r\\npicture {\\r\\n  max-width: 100%;\\r\\n  display: block;\\r\\n}\\r\\n\\r\\n/* Inherit fonts for inputs and buttons */\\r\\ninput,\\r\\nbutton,\\r\\ntextarea,\\r\\nselect {\\r\\n  font: inherit;\\r\\n}\\r\\n\\r\\n/* Remove all animations, transitions and smooth scroll for people that prefer not to see them */\\r\\n@media (prefers-reduced-motion: reduce) {\\r\\n  html:focus-within {\\r\\n    scroll-behavior: auto;\\r\\n  }\\r\\n\\r\\n  *,\\r\\n  *::before,\\r\\n  *::after {\\r\\n    animation-duration: 0.01ms !important;\\r\\n    animation-iteration-count: 1 !important;\\r\\n    transition-duration: 0.01ms !important;\\r\\n    scroll-behavior: auto !important;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* ----------- CSS RESET STYLES END ---------- */\\r\\n\\r\\n/* ----------- UTILITY CLASSES START ---------- */\\r\\nmain {\\r\\n  position: relative;\\r\\n  min-height: 380px;\\r\\n}\\r\\n\\r\\ninput[type='text'] {\\r\\n  width: 100%;\\r\\n  background-color: transparent;\\r\\n  border: none;\\r\\n  outline: none;\\r\\n  color: var(--state-color);\\r\\n}\\r\\n\\r\\n.primary-header {\\r\\n  text-transform: uppercase;\\r\\n  font-size: 32px;\\r\\n  font-weight: 700;\\r\\n  color: white;\\r\\n  letter-spacing: 4px;\\r\\n}\\r\\n\\r\\n@media screen and (min-width: 40em) {\\r\\n  .primary-header {\\r\\n    font-size: 36px;\\r\\n  }\\r\\n}\\r\\n\\r\\n.bg-todo {\\r\\n  background-color: var(--bg-todo);\\r\\n}\\r\\n\\r\\n.px-4 {\\r\\n  padding: 0.8rem 1.5rem;\\r\\n}\\r\\n\\r\\n.rounded {\\r\\n  border-radius: 0.25rem;\\r\\n}\\r\\n\\r\\n.mb-25 {\\r\\n  margin-bottom: 1.46rem;\\r\\n}\\r\\n\\r\\n.mt-50 {\\r\\n  margin-top: 2.5rem;\\r\\n}\\r\\n\\r\\n.text-status {\\r\\n  color: var(--state-color);\\r\\n}\\r\\n\\r\\n/* ----------- UTILITY CLASSES END ---------- */\\r\\n\\r\\n/* ----------- HEADER SECTION STYLES START ---------- */\\r\\nheader.hero-banner {\\r\\n  background-image: url(\" + ___CSS_LOADER_URL_REPLACEMENT_0___ + \");\\r\\n  background-repeat: no-repeat;\\r\\n  background-size: contain;\\r\\n  height: 300px;\\r\\n}\\r\\n\\r\\n@media screen and (min-width: 40em) {\\r\\n  header.hero-banner {\\r\\n    background-image: url(\" + ___CSS_LOADER_URL_REPLACEMENT_1___ + \");\\r\\n    background-size: cover;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* change the background image for light mode (automatically) */\\r\\n@media (prefers-color-scheme: dark) {\\r\\n  header.hero-banner {\\r\\n    background-image: url(\" + ___CSS_LOADER_URL_REPLACEMENT_2___ + \");\\r\\n    background-repeat: no-repeat;\\r\\n    background-size: contain;\\r\\n    height: 300px;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* change the background image for dark mode mode (automatically) */\\r\\n@media screen and (prefers-color-scheme: dark) and (min-width: 40em) {\\r\\n  header.hero-banner {\\r\\n    background-image: url(\" + ___CSS_LOADER_URL_REPLACEMENT_3___ + \");\\r\\n    background-size: cover;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* changing background image (manually) when switched to light theme */\\r\\n[color-scheme='light'] header.hero-banner {\\r\\n  background-image: url(\" + ___CSS_LOADER_URL_REPLACEMENT_1___ + \");\\r\\n  background-size: cover;\\r\\n}\\r\\n\\r\\n/* changing background image (manually) when switched to dark theme */\\r\\n[color-scheme='dark'] header.hero-banner {\\r\\n  background-image: url(\" + ___CSS_LOADER_URL_REPLACEMENT_3___ + \");\\r\\n  background-size: cover;\\r\\n}\\r\\n\\r\\n/* ----------- HEADER SECTION STYLES END ---------- */\\r\\n\\r\\n/* ----------- TO DO CONTAINER SECTION STYLES START ---------- */\\r\\n.todo-container {\\r\\n  position: absolute;\\r\\n  top: -230px;\\r\\n  left: 50%;\\r\\n  transform: translateX(-50%);\\r\\n  width: 100%;\\r\\n  max-width: 540px;\\r\\n  padding-inline: 1rem;\\r\\n  overflow-y: visible;\\r\\n}\\r\\n\\r\\n.todo-header {\\r\\n  display: flex;\\r\\n  justify-content: space-between;\\r\\n  align-items: center;\\r\\n}\\r\\n\\r\\n.themeChanger {\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n/* 1.1 form input section styles */\\r\\n.todo-input::placeholder {\\r\\n  color: var(--state-color);\\r\\n}\\r\\n\\r\\n.todo-input:focus {\\r\\n  caret-color: hsl(220deg, 98%, 61%);\\r\\n  color: var(--text-active);\\r\\n}\\r\\n\\r\\n.todo-input:focus::placeholder {\\r\\n  color: var(--text-active);\\r\\n}\\r\\n\\r\\n/* 2.2 todo list section styles  */\\r\\n@media screen and (min-width: 40em) {\\r\\n  .todo-list-container {\\r\\n    box-shadow: 0 4px 16px -2px var(--light-shadow);\\r\\n  }\\r\\n}\\r\\n\\r\\n.todo-item {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: space-between;\\r\\n  gap: 1rem;\\r\\n  text-align: left;\\r\\n  border-bottom: 1px solid var(--state-color);\\r\\n}\\r\\n\\r\\n.check {\\r\\n  width: 25px;\\r\\n  height: 20px;\\r\\n  border-radius: 50%;\\r\\n  border: 1px solid var(--state-color);\\r\\n}\\r\\n\\r\\n.check:hover {\\r\\n  border: 1px solid hsl(192deg, 100%, 67%);\\r\\n}\\r\\n\\r\\n.check.active {\\r\\n  background:\\r\\n    url(\" + ___CSS_LOADER_URL_REPLACEMENT_4___ + \"),\\r\\n    linear-gradient(to right, hsl(192deg, 100%, 67%), hsl(280deg, 87%, 65%));\\r\\n  background-repeat: no-repeat;\\r\\n  background-position: center;\\r\\n}\\r\\n\\r\\n.task {\\r\\n  padding-top: 4px;\\r\\n  width: 100%;\\r\\n  color: var(--text-active);\\r\\n}\\r\\n\\r\\ninput:checked + .task {\\r\\n  text-decoration: line-through;\\r\\n  color: var(--state-color);\\r\\n}\\r\\n\\r\\n.cross-icon {\\r\\n  margin-left: auto;\\r\\n  opacity: 0;\\r\\n  transition: all 0.2s ease;\\r\\n}\\r\\n\\r\\n.todo-item:hover {\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.todo-item:hover .cross-icon {\\r\\n  opacity: 1;\\r\\n}\\r\\n\\r\\n/* list status navigating section styles */\\r\\n.state {\\r\\n  position: relative;\\r\\n  display: flex;\\r\\n  justify-content: space-between;\\r\\n  font-size: 14px;\\r\\n  overflow: visible;\\r\\n}\\r\\n\\r\\n.stages-menu {\\r\\n  position: absolute;\\r\\n  inset: 0;\\r\\n  height: 50px;\\r\\n  top: 4.5rem;\\r\\n  background-color: var(--bg-todo);\\r\\n  display: flex;\\r\\n  justify-content: center;\\r\\n  align-items: center;\\r\\n  gap: 1rem;\\r\\n  border-radius: 0.25rem;\\r\\n}\\r\\n\\r\\n@media screen and (min-width: 40em) {\\r\\n  .stages-menu {\\r\\n    position: static;\\r\\n    height: auto;\\r\\n    background-color: transparent;\\r\\n    display: flex;\\r\\n    gap: 1rem;\\r\\n  }\\r\\n}\\r\\n\\r\\n.stage-item {\\r\\n  color: var(--state-color);\\r\\n  font-weight: 700;\\r\\n}\\r\\n\\r\\n.stage-item.active {\\r\\n  color: hsl(220deg, 98%, 61%);\\r\\n}\\r\\n\\r\\n.stage-item.active:hover {\\r\\n  color: hsl(220deg, 98%, 61%);\\r\\n}\\r\\n\\r\\n#clear {\\r\\n  text-decoration: none;\\r\\n}\\r\\n\\r\\n.stage-item:hover,\\r\\n#clear:hover {\\r\\n  cursor: pointer;\\r\\n  color: var(--state-hover-color);\\r\\n}\\r\\n\\r\\n/* -------------- FOOTER SECTION STYLES START ------------- */\\r\\np.footer {\\r\\n  text-align: center;\\r\\n  margin-top: 6rem;\\r\\n  color: var(--state-color);\\r\\n  font-size: 14px;\\r\\n}\\r\\n\\r\\n@media screen and (min-width: 40em) {\\r\\n  p.footer {\\r\\n    margin-top: 3rem;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Hide the browser's default checkbox */\\r\\ninput[type='checkbox'] {\\r\\n  position: absolute;\\r\\n  opacity: 0;\\r\\n  cursor: pointer;\\r\\n  height: 0;\\r\\n  width: 0;\\r\\n}\\r\\n\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://setup-webpack/./src/styles.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\n//# sourceURL=webpack://setup-webpack/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (!url) {\n    return url;\n  }\n\n  url = String(url.__esModule ? url.default : url); // If url is already wrapped in quotes, remove them\n\n  if (/^['\"].*['\"]$/.test(url)) {\n    url = url.slice(1, -1);\n  }\n\n  if (options.hash) {\n    url += options.hash;\n  } // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n\n\n  if (/[\"'() \\t\\n]|(%20)/.test(url) || options.needQuotes) {\n    return \"\\\"\".concat(url.replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\"), \"\\\"\");\n  }\n\n  return url;\n};\n\n//# sourceURL=webpack://setup-webpack/./node_modules/css-loader/dist/runtime/getUrl.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://setup-webpack/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./src/styles.css":
/*!************************!*\
  !*** ./src/styles.css ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./styles.css */ \"./node_modules/css-loader/dist/cjs.js!./src/styles.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://setup-webpack/./src/styles.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://setup-webpack/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://setup-webpack/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://setup-webpack/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://setup-webpack/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://setup-webpack/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://setup-webpack/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_Start_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/Start.js */ \"./src/modules/Start.js\");\n/* eslint-disable linebreak-style */\r\n\r\n\r\n(0,_modules_Start_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\r\n\n\n//# sourceURL=webpack://setup-webpack/./src/index.js?");

/***/ }),

/***/ "./src/modules/Sortable.js":
/*!*********************************!*\
  !*** ./src/modules/Sortable.js ***!
  \*********************************/
/***/ (function(module) {

eval("/**!\r\n * Sortable 1.15.0\r\n * @author\tRubaXa   <trash@rubaxa.org>\r\n * @author\towenm    <owen23355@gmail.com>\r\n * @license MIT\r\n */\r\n(function (global, factory) {\r\n   true ? module.exports = factory() :\r\n  0;\r\n}(this, (function () { 'use strict';\r\n\r\n  function ownKeys(object, enumerableOnly) {\r\n    var keys = Object.keys(object);\r\n\r\n    if (Object.getOwnPropertySymbols) {\r\n      var symbols = Object.getOwnPropertySymbols(object);\r\n\r\n      if (enumerableOnly) {\r\n        symbols = symbols.filter(function (sym) {\r\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\r\n        });\r\n      }\r\n\r\n      keys.push.apply(keys, symbols);\r\n    }\r\n\r\n    return keys;\r\n  }\r\n\r\n  function _objectSpread2(target) {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      var source = arguments[i] != null ? arguments[i] : {};\r\n\r\n      if (i % 2) {\r\n        ownKeys(Object(source), true).forEach(function (key) {\r\n          _defineProperty(target, key, source[key]);\r\n        });\r\n      } else if (Object.getOwnPropertyDescriptors) {\r\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\r\n      } else {\r\n        ownKeys(Object(source)).forEach(function (key) {\r\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\r\n        });\r\n      }\r\n    }\r\n\r\n    return target;\r\n  }\r\n\r\n  function _typeof(obj) {\r\n    \"@babel/helpers - typeof\";\r\n\r\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\r\n      _typeof = function (obj) {\r\n        return typeof obj;\r\n      };\r\n    } else {\r\n      _typeof = function (obj) {\r\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\r\n      };\r\n    }\r\n\r\n    return _typeof(obj);\r\n  }\r\n\r\n  function _defineProperty(obj, key, value) {\r\n    if (key in obj) {\r\n      Object.defineProperty(obj, key, {\r\n        value: value,\r\n        enumerable: true,\r\n        configurable: true,\r\n        writable: true\r\n      });\r\n    } else {\r\n      obj[key] = value;\r\n    }\r\n\r\n    return obj;\r\n  }\r\n\r\n  function _extends() {\r\n    _extends = Object.assign || function (target) {\r\n      for (var i = 1; i < arguments.length; i++) {\r\n        var source = arguments[i];\r\n\r\n        for (var key in source) {\r\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n            target[key] = source[key];\r\n          }\r\n        }\r\n      }\r\n\r\n      return target;\r\n    };\r\n\r\n    return _extends.apply(this, arguments);\r\n  }\r\n\r\n  function _objectWithoutPropertiesLoose(source, excluded) {\r\n    if (source == null) return {};\r\n    var target = {};\r\n    var sourceKeys = Object.keys(source);\r\n    var key, i;\r\n\r\n    for (i = 0; i < sourceKeys.length; i++) {\r\n      key = sourceKeys[i];\r\n      if (excluded.indexOf(key) >= 0) continue;\r\n      target[key] = source[key];\r\n    }\r\n\r\n    return target;\r\n  }\r\n\r\n  function _objectWithoutProperties(source, excluded) {\r\n    if (source == null) return {};\r\n\r\n    var target = _objectWithoutPropertiesLoose(source, excluded);\r\n\r\n    var key, i;\r\n\r\n    if (Object.getOwnPropertySymbols) {\r\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\r\n\r\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\r\n        key = sourceSymbolKeys[i];\r\n        if (excluded.indexOf(key) >= 0) continue;\r\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\r\n        target[key] = source[key];\r\n      }\r\n    }\r\n\r\n    return target;\r\n  }\r\n\r\n  function _toConsumableArray(arr) {\r\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\r\n  }\r\n\r\n  function _arrayWithoutHoles(arr) {\r\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\r\n  }\r\n\r\n  function _iterableToArray(iter) {\r\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\r\n  }\r\n\r\n  function _unsupportedIterableToArray(o, minLen) {\r\n    if (!o) return;\r\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\r\n    var n = Object.prototype.toString.call(o).slice(8, -1);\r\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\r\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\r\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\r\n  }\r\n\r\n  function _arrayLikeToArray(arr, len) {\r\n    if (len == null || len > arr.length) len = arr.length;\r\n\r\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\r\n\r\n    return arr2;\r\n  }\r\n\r\n  function _nonIterableSpread() {\r\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\r\n  }\r\n\r\n  var version = \"1.15.0\";\r\n\r\n  function userAgent(pattern) {\r\n    if (typeof window !== 'undefined' && window.navigator) {\r\n      return !! /*@__PURE__*/navigator.userAgent.match(pattern);\r\n    }\r\n  }\r\n\r\n  var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\\.|msie|iemobile|Windows Phone)/i);\r\n  var Edge = userAgent(/Edge/i);\r\n  var FireFox = userAgent(/firefox/i);\r\n  var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);\r\n  var IOS = userAgent(/iP(ad|od|hone)/i);\r\n  var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);\r\n\r\n  var captureMode = {\r\n    capture: false,\r\n    passive: false\r\n  };\r\n\r\n  function on(el, event, fn) {\r\n    el.addEventListener(event, fn, !IE11OrLess && captureMode);\r\n  }\r\n\r\n  function off(el, event, fn) {\r\n    el.removeEventListener(event, fn, !IE11OrLess && captureMode);\r\n  }\r\n\r\n  function matches(\r\n  /**HTMLElement*/\r\n  el,\r\n  /**String*/\r\n  selector) {\r\n    if (!selector) return;\r\n    selector[0] === '>' && (selector = selector.substring(1));\r\n\r\n    if (el) {\r\n      try {\r\n        if (el.matches) {\r\n          return el.matches(selector);\r\n        } else if (el.msMatchesSelector) {\r\n          return el.msMatchesSelector(selector);\r\n        } else if (el.webkitMatchesSelector) {\r\n          return el.webkitMatchesSelector(selector);\r\n        }\r\n      } catch (_) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  function getParentOrHost(el) {\r\n    return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;\r\n  }\r\n\r\n  function closest(\r\n  /**HTMLElement*/\r\n  el,\r\n  /**String*/\r\n  selector,\r\n  /**HTMLElement*/\r\n  ctx, includeCTX) {\r\n    if (el) {\r\n      ctx = ctx || document;\r\n\r\n      do {\r\n        if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {\r\n          return el;\r\n        }\r\n\r\n        if (el === ctx) break;\r\n        /* jshint boss:true */\r\n      } while (el = getParentOrHost(el));\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  var R_SPACE = /\\s+/g;\r\n\r\n  function toggleClass(el, name, state) {\r\n    if (el && name) {\r\n      if (el.classList) {\r\n        el.classList[state ? 'add' : 'remove'](name);\r\n      } else {\r\n        var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');\r\n        el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');\r\n      }\r\n    }\r\n  }\r\n\r\n  function css(el, prop, val) {\r\n    var style = el && el.style;\r\n\r\n    if (style) {\r\n      if (val === void 0) {\r\n        if (document.defaultView && document.defaultView.getComputedStyle) {\r\n          val = document.defaultView.getComputedStyle(el, '');\r\n        } else if (el.currentStyle) {\r\n          val = el.currentStyle;\r\n        }\r\n\r\n        return prop === void 0 ? val : val[prop];\r\n      } else {\r\n        if (!(prop in style) && prop.indexOf('webkit') === -1) {\r\n          prop = '-webkit-' + prop;\r\n        }\r\n\r\n        style[prop] = val + (typeof val === 'string' ? '' : 'px');\r\n      }\r\n    }\r\n  }\r\n\r\n  function matrix(el, selfOnly) {\r\n    var appliedTransforms = '';\r\n\r\n    if (typeof el === 'string') {\r\n      appliedTransforms = el;\r\n    } else {\r\n      do {\r\n        var transform = css(el, 'transform');\r\n\r\n        if (transform && transform !== 'none') {\r\n          appliedTransforms = transform + ' ' + appliedTransforms;\r\n        }\r\n        /* jshint boss:true */\r\n\r\n      } while (!selfOnly && (el = el.parentNode));\r\n    }\r\n\r\n    var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;\r\n    /*jshint -W056 */\r\n\r\n    return matrixFn && new matrixFn(appliedTransforms);\r\n  }\r\n\r\n  function find(ctx, tagName, iterator) {\r\n    if (ctx) {\r\n      var list = ctx.getElementsByTagName(tagName),\r\n          i = 0,\r\n          n = list.length;\r\n\r\n      if (iterator) {\r\n        for (; i < n; i++) {\r\n          iterator(list[i], i);\r\n        }\r\n      }\r\n\r\n      return list;\r\n    }\r\n\r\n    return [];\r\n  }\r\n\r\n  function getWindowScrollingElement() {\r\n    var scrollingElement = document.scrollingElement;\r\n\r\n    if (scrollingElement) {\r\n      return scrollingElement;\r\n    } else {\r\n      return document.documentElement;\r\n    }\r\n  }\r\n  /**\r\n   * Returns the \"bounding client rect\" of given element\r\n   * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\r\n   * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\r\n   * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\r\n   * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\r\n   * @param  {[HTMLElement]} container              The parent the element will be placed in\r\n   * @return {Object}                               The boundingClientRect of el, with specified adjustments\r\n   */\r\n\r\n\r\n  function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {\r\n    if (!el.getBoundingClientRect && el !== window) return;\r\n    var elRect, top, left, bottom, right, height, width;\r\n\r\n    if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {\r\n      elRect = el.getBoundingClientRect();\r\n      top = elRect.top;\r\n      left = elRect.left;\r\n      bottom = elRect.bottom;\r\n      right = elRect.right;\r\n      height = elRect.height;\r\n      width = elRect.width;\r\n    } else {\r\n      top = 0;\r\n      left = 0;\r\n      bottom = window.innerHeight;\r\n      right = window.innerWidth;\r\n      height = window.innerHeight;\r\n      width = window.innerWidth;\r\n    }\r\n\r\n    if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {\r\n      // Adjust for translate()\r\n      container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\r\n      // Not needed on <= IE11\r\n\r\n      if (!IE11OrLess) {\r\n        do {\r\n          if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {\r\n            var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container\r\n\r\n            top -= containerRect.top + parseInt(css(container, 'border-top-width'));\r\n            left -= containerRect.left + parseInt(css(container, 'border-left-width'));\r\n            bottom = top + elRect.height;\r\n            right = left + elRect.width;\r\n            break;\r\n          }\r\n          /* jshint boss:true */\r\n\r\n        } while (container = container.parentNode);\r\n      }\r\n    }\r\n\r\n    if (undoScale && el !== window) {\r\n      // Adjust for scale()\r\n      var elMatrix = matrix(container || el),\r\n          scaleX = elMatrix && elMatrix.a,\r\n          scaleY = elMatrix && elMatrix.d;\r\n\r\n      if (elMatrix) {\r\n        top /= scaleY;\r\n        left /= scaleX;\r\n        width /= scaleX;\r\n        height /= scaleY;\r\n        bottom = top + height;\r\n        right = left + width;\r\n      }\r\n    }\r\n\r\n    return {\r\n      top: top,\r\n      left: left,\r\n      bottom: bottom,\r\n      right: right,\r\n      width: width,\r\n      height: height\r\n    };\r\n  }\r\n  /**\r\n   * Checks if a side of an element is scrolled past a side of its parents\r\n   * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\r\n   * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\r\n   * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\r\n   * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element\r\n   */\r\n\r\n\r\n  function isScrolledPast(el, elSide, parentSide) {\r\n    var parent = getParentAutoScrollElement(el, true),\r\n        elSideVal = getRect(el)[elSide];\r\n    /* jshint boss:true */\r\n\r\n    while (parent) {\r\n      var parentSideVal = getRect(parent)[parentSide],\r\n          visible = void 0;\r\n\r\n      if (parentSide === 'top' || parentSide === 'left') {\r\n        visible = elSideVal >= parentSideVal;\r\n      } else {\r\n        visible = elSideVal <= parentSideVal;\r\n      }\r\n\r\n      if (!visible) return parent;\r\n      if (parent === getWindowScrollingElement()) break;\r\n      parent = getParentAutoScrollElement(parent, false);\r\n    }\r\n\r\n    return false;\r\n  }\r\n  /**\r\n   * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\r\n   * and non-draggable elements\r\n   * @param  {HTMLElement} el       The parent element\r\n   * @param  {Number} childNum      The index of the child\r\n   * @param  {Object} options       Parent Sortable's options\r\n   * @return {HTMLElement}          The child at index childNum, or null if not found\r\n   */\r\n\r\n\r\n  function getChild(el, childNum, options, includeDragEl) {\r\n    var currentChild = 0,\r\n        i = 0,\r\n        children = el.children;\r\n\r\n    while (i < children.length) {\r\n      if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {\r\n        if (currentChild === childNum) {\r\n          return children[i];\r\n        }\r\n\r\n        currentChild++;\r\n      }\r\n\r\n      i++;\r\n    }\r\n\r\n    return null;\r\n  }\r\n  /**\r\n   * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\r\n   * @param  {HTMLElement} el       Parent element\r\n   * @param  {selector} selector    Any other elements that should be ignored\r\n   * @return {HTMLElement}          The last child, ignoring ghostEl\r\n   */\r\n\r\n\r\n  function lastChild(el, selector) {\r\n    var last = el.lastElementChild;\r\n\r\n    while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {\r\n      last = last.previousElementSibling;\r\n    }\r\n\r\n    return last || null;\r\n  }\r\n  /**\r\n   * Returns the index of an element within its parent for a selected set of\r\n   * elements\r\n   * @param  {HTMLElement} el\r\n   * @param  {selector} selector\r\n   * @return {number}\r\n   */\r\n\r\n\r\n  function index(el, selector) {\r\n    var index = 0;\r\n\r\n    if (!el || !el.parentNode) {\r\n      return -1;\r\n    }\r\n    /* jshint boss:true */\r\n\r\n\r\n    while (el = el.previousElementSibling) {\r\n      if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {\r\n        index++;\r\n      }\r\n    }\r\n\r\n    return index;\r\n  }\r\n  /**\r\n   * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\r\n   * The value is returned in real pixels.\r\n   * @param  {HTMLElement} el\r\n   * @return {Array}             Offsets in the format of [left, top]\r\n   */\r\n\r\n\r\n  function getRelativeScrollOffset(el) {\r\n    var offsetLeft = 0,\r\n        offsetTop = 0,\r\n        winScroller = getWindowScrollingElement();\r\n\r\n    if (el) {\r\n      do {\r\n        var elMatrix = matrix(el),\r\n            scaleX = elMatrix.a,\r\n            scaleY = elMatrix.d;\r\n        offsetLeft += el.scrollLeft * scaleX;\r\n        offsetTop += el.scrollTop * scaleY;\r\n      } while (el !== winScroller && (el = el.parentNode));\r\n    }\r\n\r\n    return [offsetLeft, offsetTop];\r\n  }\r\n  /**\r\n   * Returns the index of the object within the given array\r\n   * @param  {Array} arr   Array that may or may not hold the object\r\n   * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\r\n   * @return {Number}      The index of the object in the array, or -1\r\n   */\r\n\r\n\r\n  function indexOfObject(arr, obj) {\r\n    for (var i in arr) {\r\n      if (!arr.hasOwnProperty(i)) continue;\r\n\r\n      for (var key in obj) {\r\n        if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\r\n      }\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  function getParentAutoScrollElement(el, includeSelf) {\r\n    // skip to window\r\n    if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();\r\n    var elem = el;\r\n    var gotSelf = false;\r\n\r\n    do {\r\n      // we don't need to get elem css if it isn't even overflowing in the first place (performance)\r\n      if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {\r\n        var elemCSS = css(elem);\r\n\r\n        if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {\r\n          if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();\r\n          if (gotSelf || includeSelf) return elem;\r\n          gotSelf = true;\r\n        }\r\n      }\r\n      /* jshint boss:true */\r\n\r\n    } while (elem = elem.parentNode);\r\n\r\n    return getWindowScrollingElement();\r\n  }\r\n\r\n  function extend(dst, src) {\r\n    if (dst && src) {\r\n      for (var key in src) {\r\n        if (src.hasOwnProperty(key)) {\r\n          dst[key] = src[key];\r\n        }\r\n      }\r\n    }\r\n\r\n    return dst;\r\n  }\r\n\r\n  function isRectEqual(rect1, rect2) {\r\n    return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);\r\n  }\r\n\r\n  var _throttleTimeout;\r\n\r\n  function throttle(callback, ms) {\r\n    return function () {\r\n      if (!_throttleTimeout) {\r\n        var args = arguments,\r\n            _this = this;\r\n\r\n        if (args.length === 1) {\r\n          callback.call(_this, args[0]);\r\n        } else {\r\n          callback.apply(_this, args);\r\n        }\r\n\r\n        _throttleTimeout = setTimeout(function () {\r\n          _throttleTimeout = void 0;\r\n        }, ms);\r\n      }\r\n    };\r\n  }\r\n\r\n  function cancelThrottle() {\r\n    clearTimeout(_throttleTimeout);\r\n    _throttleTimeout = void 0;\r\n  }\r\n\r\n  function scrollBy(el, x, y) {\r\n    el.scrollLeft += x;\r\n    el.scrollTop += y;\r\n  }\r\n\r\n  function clone(el) {\r\n    var Polymer = window.Polymer;\r\n    var $ = window.jQuery || window.Zepto;\r\n\r\n    if (Polymer && Polymer.dom) {\r\n      return Polymer.dom(el).cloneNode(true);\r\n    } else if ($) {\r\n      return $(el).clone(true)[0];\r\n    } else {\r\n      return el.cloneNode(true);\r\n    }\r\n  }\r\n\r\n  function setRect(el, rect) {\r\n    css(el, 'position', 'absolute');\r\n    css(el, 'top', rect.top);\r\n    css(el, 'left', rect.left);\r\n    css(el, 'width', rect.width);\r\n    css(el, 'height', rect.height);\r\n  }\r\n\r\n  function unsetRect(el) {\r\n    css(el, 'position', '');\r\n    css(el, 'top', '');\r\n    css(el, 'left', '');\r\n    css(el, 'width', '');\r\n    css(el, 'height', '');\r\n  }\r\n\r\n  var expando = 'Sortable' + new Date().getTime();\r\n\r\n  function AnimationStateManager() {\r\n    var animationStates = [],\r\n        animationCallbackId;\r\n    return {\r\n      captureAnimationState: function captureAnimationState() {\r\n        animationStates = [];\r\n        if (!this.options.animation) return;\r\n        var children = [].slice.call(this.el.children);\r\n        children.forEach(function (child) {\r\n          if (css(child, 'display') === 'none' || child === Sortable.ghost) return;\r\n          animationStates.push({\r\n            target: child,\r\n            rect: getRect(child)\r\n          });\r\n\r\n          var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation\r\n\r\n\r\n          if (child.thisAnimationDuration) {\r\n            var childMatrix = matrix(child, true);\r\n\r\n            if (childMatrix) {\r\n              fromRect.top -= childMatrix.f;\r\n              fromRect.left -= childMatrix.e;\r\n            }\r\n          }\r\n\r\n          child.fromRect = fromRect;\r\n        });\r\n      },\r\n      addAnimationState: function addAnimationState(state) {\r\n        animationStates.push(state);\r\n      },\r\n      removeAnimationState: function removeAnimationState(target) {\r\n        animationStates.splice(indexOfObject(animationStates, {\r\n          target: target\r\n        }), 1);\r\n      },\r\n      animateAll: function animateAll(callback) {\r\n        var _this = this;\r\n\r\n        if (!this.options.animation) {\r\n          clearTimeout(animationCallbackId);\r\n          if (typeof callback === 'function') callback();\r\n          return;\r\n        }\r\n\r\n        var animating = false,\r\n            animationTime = 0;\r\n        animationStates.forEach(function (state) {\r\n          var time = 0,\r\n              target = state.target,\r\n              fromRect = target.fromRect,\r\n              toRect = getRect(target),\r\n              prevFromRect = target.prevFromRect,\r\n              prevToRect = target.prevToRect,\r\n              animatingRect = state.rect,\r\n              targetMatrix = matrix(target, true);\r\n\r\n          if (targetMatrix) {\r\n            // Compensate for current animation\r\n            toRect.top -= targetMatrix.f;\r\n            toRect.left -= targetMatrix.e;\r\n          }\r\n\r\n          target.toRect = toRect;\r\n\r\n          if (target.thisAnimationDuration) {\r\n            // Could also check if animatingRect is between fromRect and toRect\r\n            if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect\r\n            (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {\r\n              // If returning to same place as started from animation and on same axis\r\n              time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);\r\n            }\r\n          } // if fromRect != toRect: animate\r\n\r\n\r\n          if (!isRectEqual(toRect, fromRect)) {\r\n            target.prevFromRect = fromRect;\r\n            target.prevToRect = toRect;\r\n\r\n            if (!time) {\r\n              time = _this.options.animation;\r\n            }\r\n\r\n            _this.animate(target, animatingRect, toRect, time);\r\n          }\r\n\r\n          if (time) {\r\n            animating = true;\r\n            animationTime = Math.max(animationTime, time);\r\n            clearTimeout(target.animationResetTimer);\r\n            target.animationResetTimer = setTimeout(function () {\r\n              target.animationTime = 0;\r\n              target.prevFromRect = null;\r\n              target.fromRect = null;\r\n              target.prevToRect = null;\r\n              target.thisAnimationDuration = null;\r\n            }, time);\r\n            target.thisAnimationDuration = time;\r\n          }\r\n        });\r\n        clearTimeout(animationCallbackId);\r\n\r\n        if (!animating) {\r\n          if (typeof callback === 'function') callback();\r\n        } else {\r\n          animationCallbackId = setTimeout(function () {\r\n            if (typeof callback === 'function') callback();\r\n          }, animationTime);\r\n        }\r\n\r\n        animationStates = [];\r\n      },\r\n      animate: function animate(target, currentRect, toRect, duration) {\r\n        if (duration) {\r\n          css(target, 'transition', '');\r\n          css(target, 'transform', '');\r\n          var elMatrix = matrix(this.el),\r\n              scaleX = elMatrix && elMatrix.a,\r\n              scaleY = elMatrix && elMatrix.d,\r\n              translateX = (currentRect.left - toRect.left) / (scaleX || 1),\r\n              translateY = (currentRect.top - toRect.top) / (scaleY || 1);\r\n          target.animatingX = !!translateX;\r\n          target.animatingY = !!translateY;\r\n          css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');\r\n          this.forRepaintDummy = repaint(target); // repaint\r\n\r\n          css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));\r\n          css(target, 'transform', 'translate3d(0,0,0)');\r\n          typeof target.animated === 'number' && clearTimeout(target.animated);\r\n          target.animated = setTimeout(function () {\r\n            css(target, 'transition', '');\r\n            css(target, 'transform', '');\r\n            target.animated = false;\r\n            target.animatingX = false;\r\n            target.animatingY = false;\r\n          }, duration);\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  function repaint(target) {\r\n    return target.offsetWidth;\r\n  }\r\n\r\n  function calculateRealTime(animatingRect, fromRect, toRect, options) {\r\n    return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;\r\n  }\r\n\r\n  var plugins = [];\r\n  var defaults = {\r\n    initializeByDefault: true\r\n  };\r\n  var PluginManager = {\r\n    mount: function mount(plugin) {\r\n      // Set default static properties\r\n      for (var option in defaults) {\r\n        if (defaults.hasOwnProperty(option) && !(option in plugin)) {\r\n          plugin[option] = defaults[option];\r\n        }\r\n      }\r\n\r\n      plugins.forEach(function (p) {\r\n        if (p.pluginName === plugin.pluginName) {\r\n          throw \"Sortable: Cannot mount plugin \".concat(plugin.pluginName, \" more than once\");\r\n        }\r\n      });\r\n      plugins.push(plugin);\r\n    },\r\n    pluginEvent: function pluginEvent(eventName, sortable, evt) {\r\n      var _this = this;\r\n\r\n      this.eventCanceled = false;\r\n\r\n      evt.cancel = function () {\r\n        _this.eventCanceled = true;\r\n      };\r\n\r\n      var eventNameGlobal = eventName + 'Global';\r\n      plugins.forEach(function (plugin) {\r\n        if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable\r\n\r\n        if (sortable[plugin.pluginName][eventNameGlobal]) {\r\n          sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({\r\n            sortable: sortable\r\n          }, evt));\r\n        } // Only fire plugin event if plugin is enabled in this sortable,\r\n        // and plugin has event defined\r\n\r\n\r\n        if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {\r\n          sortable[plugin.pluginName][eventName](_objectSpread2({\r\n            sortable: sortable\r\n          }, evt));\r\n        }\r\n      });\r\n    },\r\n    initializePlugins: function initializePlugins(sortable, el, defaults, options) {\r\n      plugins.forEach(function (plugin) {\r\n        var pluginName = plugin.pluginName;\r\n        if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;\r\n        var initialized = new plugin(sortable, el, sortable.options);\r\n        initialized.sortable = sortable;\r\n        initialized.options = sortable.options;\r\n        sortable[pluginName] = initialized; // Add default options from plugin\r\n\r\n        _extends(defaults, initialized.defaults);\r\n      });\r\n\r\n      for (var option in sortable.options) {\r\n        if (!sortable.options.hasOwnProperty(option)) continue;\r\n        var modified = this.modifyOption(sortable, option, sortable.options[option]);\r\n\r\n        if (typeof modified !== 'undefined') {\r\n          sortable.options[option] = modified;\r\n        }\r\n      }\r\n    },\r\n    getEventProperties: function getEventProperties(name, sortable) {\r\n      var eventProperties = {};\r\n      plugins.forEach(function (plugin) {\r\n        if (typeof plugin.eventProperties !== 'function') return;\r\n\r\n        _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));\r\n      });\r\n      return eventProperties;\r\n    },\r\n    modifyOption: function modifyOption(sortable, name, value) {\r\n      var modifiedValue;\r\n      plugins.forEach(function (plugin) {\r\n        // Plugin must exist on the Sortable\r\n        if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin\r\n\r\n        if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {\r\n          modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);\r\n        }\r\n      });\r\n      return modifiedValue;\r\n    }\r\n  };\r\n\r\n  function dispatchEvent(_ref) {\r\n    var sortable = _ref.sortable,\r\n        rootEl = _ref.rootEl,\r\n        name = _ref.name,\r\n        targetEl = _ref.targetEl,\r\n        cloneEl = _ref.cloneEl,\r\n        toEl = _ref.toEl,\r\n        fromEl = _ref.fromEl,\r\n        oldIndex = _ref.oldIndex,\r\n        newIndex = _ref.newIndex,\r\n        oldDraggableIndex = _ref.oldDraggableIndex,\r\n        newDraggableIndex = _ref.newDraggableIndex,\r\n        originalEvent = _ref.originalEvent,\r\n        putSortable = _ref.putSortable,\r\n        extraEventProperties = _ref.extraEventProperties;\r\n    sortable = sortable || rootEl && rootEl[expando];\r\n    if (!sortable) return;\r\n    var evt,\r\n        options = sortable.options,\r\n        onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature\r\n\r\n    if (window.CustomEvent && !IE11OrLess && !Edge) {\r\n      evt = new CustomEvent(name, {\r\n        bubbles: true,\r\n        cancelable: true\r\n      });\r\n    } else {\r\n      evt = document.createEvent('Event');\r\n      evt.initEvent(name, true, true);\r\n    }\r\n\r\n    evt.to = toEl || rootEl;\r\n    evt.from = fromEl || rootEl;\r\n    evt.item = targetEl || rootEl;\r\n    evt.clone = cloneEl;\r\n    evt.oldIndex = oldIndex;\r\n    evt.newIndex = newIndex;\r\n    evt.oldDraggableIndex = oldDraggableIndex;\r\n    evt.newDraggableIndex = newDraggableIndex;\r\n    evt.originalEvent = originalEvent;\r\n    evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;\r\n\r\n    var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));\r\n\r\n    for (var option in allEventProperties) {\r\n      evt[option] = allEventProperties[option];\r\n    }\r\n\r\n    if (rootEl) {\r\n      rootEl.dispatchEvent(evt);\r\n    }\r\n\r\n    if (options[onName]) {\r\n      options[onName].call(sortable, evt);\r\n    }\r\n  }\r\n\r\n  var _excluded = [\"evt\"];\r\n\r\n  var pluginEvent = function pluginEvent(eventName, sortable) {\r\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\r\n        originalEvent = _ref.evt,\r\n        data = _objectWithoutProperties(_ref, _excluded);\r\n\r\n    PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({\r\n      dragEl: dragEl,\r\n      parentEl: parentEl,\r\n      ghostEl: ghostEl,\r\n      rootEl: rootEl,\r\n      nextEl: nextEl,\r\n      lastDownEl: lastDownEl,\r\n      cloneEl: cloneEl,\r\n      cloneHidden: cloneHidden,\r\n      dragStarted: moved,\r\n      putSortable: putSortable,\r\n      activeSortable: Sortable.active,\r\n      originalEvent: originalEvent,\r\n      oldIndex: oldIndex,\r\n      oldDraggableIndex: oldDraggableIndex,\r\n      newIndex: newIndex,\r\n      newDraggableIndex: newDraggableIndex,\r\n      hideGhostForTarget: _hideGhostForTarget,\r\n      unhideGhostForTarget: _unhideGhostForTarget,\r\n      cloneNowHidden: function cloneNowHidden() {\r\n        cloneHidden = true;\r\n      },\r\n      cloneNowShown: function cloneNowShown() {\r\n        cloneHidden = false;\r\n      },\r\n      dispatchSortableEvent: function dispatchSortableEvent(name) {\r\n        _dispatchEvent({\r\n          sortable: sortable,\r\n          name: name,\r\n          originalEvent: originalEvent\r\n        });\r\n      }\r\n    }, data));\r\n  };\r\n\r\n  function _dispatchEvent(info) {\r\n    dispatchEvent(_objectSpread2({\r\n      putSortable: putSortable,\r\n      cloneEl: cloneEl,\r\n      targetEl: dragEl,\r\n      rootEl: rootEl,\r\n      oldIndex: oldIndex,\r\n      oldDraggableIndex: oldDraggableIndex,\r\n      newIndex: newIndex,\r\n      newDraggableIndex: newDraggableIndex\r\n    }, info));\r\n  }\r\n\r\n  var dragEl,\r\n      parentEl,\r\n      ghostEl,\r\n      rootEl,\r\n      nextEl,\r\n      lastDownEl,\r\n      cloneEl,\r\n      cloneHidden,\r\n      oldIndex,\r\n      newIndex,\r\n      oldDraggableIndex,\r\n      newDraggableIndex,\r\n      activeGroup,\r\n      putSortable,\r\n      awaitingDragStarted = false,\r\n      ignoreNextClick = false,\r\n      sortables = [],\r\n      tapEvt,\r\n      touchEvt,\r\n      lastDx,\r\n      lastDy,\r\n      tapDistanceLeft,\r\n      tapDistanceTop,\r\n      moved,\r\n      lastTarget,\r\n      lastDirection,\r\n      pastFirstInvertThresh = false,\r\n      isCircumstantialInvert = false,\r\n      targetMoveDistance,\r\n      // For positioning ghost absolutely\r\n  ghostRelativeParent,\r\n      ghostRelativeParentInitialScroll = [],\r\n      // (left, top)\r\n  _silent = false,\r\n      savedInputChecked = [];\r\n  /** @const */\r\n\r\n  var documentExists = typeof document !== 'undefined',\r\n      PositionGhostAbsolutely = IOS,\r\n      CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',\r\n      // This will not pass for IE9, because IE9 DnD only works on anchors\r\n  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),\r\n      supportCssPointerEvents = function () {\r\n    if (!documentExists) return; // false when <= IE11\r\n\r\n    if (IE11OrLess) {\r\n      return false;\r\n    }\r\n\r\n    var el = document.createElement('x');\r\n    el.style.cssText = 'pointer-events:auto';\r\n    return el.style.pointerEvents === 'auto';\r\n  }(),\r\n      _detectDirection = function _detectDirection(el, options) {\r\n    var elCSS = css(el),\r\n        elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),\r\n        child1 = getChild(el, 0, options),\r\n        child2 = getChild(el, 1, options),\r\n        firstChildCSS = child1 && css(child1),\r\n        secondChildCSS = child2 && css(child2),\r\n        firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,\r\n        secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;\r\n\r\n    if (elCSS.display === 'flex') {\r\n      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';\r\n    }\r\n\r\n    if (elCSS.display === 'grid') {\r\n      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';\r\n    }\r\n\r\n    if (child1 && firstChildCSS[\"float\"] && firstChildCSS[\"float\"] !== 'none') {\r\n      var touchingSideChild2 = firstChildCSS[\"float\"] === 'left' ? 'left' : 'right';\r\n      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';\r\n    }\r\n\r\n    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';\r\n  },\r\n      _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {\r\n    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,\r\n        dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,\r\n        dragElOppLength = vertical ? dragRect.width : dragRect.height,\r\n        targetS1Opp = vertical ? targetRect.left : targetRect.top,\r\n        targetS2Opp = vertical ? targetRect.right : targetRect.bottom,\r\n        targetOppLength = vertical ? targetRect.width : targetRect.height;\r\n    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;\r\n  },\r\n\r\n  /**\r\n   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\r\n   * @param  {Number} x      X position\r\n   * @param  {Number} y      Y position\r\n   * @return {HTMLElement}   Element of the first found nearest Sortable\r\n   */\r\n  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {\r\n    var ret;\r\n    sortables.some(function (sortable) {\r\n      var threshold = sortable[expando].options.emptyInsertThreshold;\r\n      if (!threshold || lastChild(sortable)) return;\r\n      var rect = getRect(sortable),\r\n          insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,\r\n          insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;\r\n\r\n      if (insideHorizontally && insideVertically) {\r\n        return ret = sortable;\r\n      }\r\n    });\r\n    return ret;\r\n  },\r\n      _prepareGroup = function _prepareGroup(options) {\r\n    function toFn(value, pull) {\r\n      return function (to, from, dragEl, evt) {\r\n        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;\r\n\r\n        if (value == null && (pull || sameGroup)) {\r\n          // Default pull value\r\n          // Default pull and put value if same group\r\n          return true;\r\n        } else if (value == null || value === false) {\r\n          return false;\r\n        } else if (pull && value === 'clone') {\r\n          return value;\r\n        } else if (typeof value === 'function') {\r\n          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);\r\n        } else {\r\n          var otherGroup = (pull ? to : from).options.group.name;\r\n          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;\r\n        }\r\n      };\r\n    }\r\n\r\n    var group = {};\r\n    var originalGroup = options.group;\r\n\r\n    if (!originalGroup || _typeof(originalGroup) != 'object') {\r\n      originalGroup = {\r\n        name: originalGroup\r\n      };\r\n    }\r\n\r\n    group.name = originalGroup.name;\r\n    group.checkPull = toFn(originalGroup.pull, true);\r\n    group.checkPut = toFn(originalGroup.put);\r\n    group.revertClone = originalGroup.revertClone;\r\n    options.group = group;\r\n  },\r\n      _hideGhostForTarget = function _hideGhostForTarget() {\r\n    if (!supportCssPointerEvents && ghostEl) {\r\n      css(ghostEl, 'display', 'none');\r\n    }\r\n  },\r\n      _unhideGhostForTarget = function _unhideGhostForTarget() {\r\n    if (!supportCssPointerEvents && ghostEl) {\r\n      css(ghostEl, 'display', '');\r\n    }\r\n  }; // #1184 fix - Prevent click event on fallback if dragged but item not changed position\r\n\r\n\r\n  if (documentExists && !ChromeForAndroid) {\r\n    document.addEventListener('click', function (evt) {\r\n      if (ignoreNextClick) {\r\n        evt.preventDefault();\r\n        evt.stopPropagation && evt.stopPropagation();\r\n        evt.stopImmediatePropagation && evt.stopImmediatePropagation();\r\n        ignoreNextClick = false;\r\n        return false;\r\n      }\r\n    }, true);\r\n  }\r\n\r\n  var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {\r\n    if (dragEl) {\r\n      evt = evt.touches ? evt.touches[0] : evt;\r\n\r\n      var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);\r\n\r\n      if (nearest) {\r\n        // Create imitation event\r\n        var event = {};\r\n\r\n        for (var i in evt) {\r\n          if (evt.hasOwnProperty(i)) {\r\n            event[i] = evt[i];\r\n          }\r\n        }\r\n\r\n        event.target = event.rootEl = nearest;\r\n        event.preventDefault = void 0;\r\n        event.stopPropagation = void 0;\r\n\r\n        nearest[expando]._onDragOver(event);\r\n      }\r\n    }\r\n  };\r\n\r\n  var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {\r\n    if (dragEl) {\r\n      dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\r\n    }\r\n  };\r\n  /**\r\n   * @class  Sortable\r\n   * @param  {HTMLElement}  el\r\n   * @param  {Object}       [options]\r\n   */\r\n\r\n\r\n  function Sortable(el, options) {\r\n    if (!(el && el.nodeType && el.nodeType === 1)) {\r\n      throw \"Sortable: `el` must be an HTMLElement, not \".concat({}.toString.call(el));\r\n    }\r\n\r\n    this.el = el; // root element\r\n\r\n    this.options = options = _extends({}, options); // Export instance\r\n\r\n    el[expando] = this;\r\n    var defaults = {\r\n      group: null,\r\n      sort: true,\r\n      disabled: false,\r\n      store: null,\r\n      handle: null,\r\n      draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',\r\n      swapThreshold: 1,\r\n      // percentage; 0 <= x <= 1\r\n      invertSwap: false,\r\n      // invert always\r\n      invertedSwapThreshold: null,\r\n      // will be set to same as swapThreshold if default\r\n      removeCloneOnHide: true,\r\n      direction: function direction() {\r\n        return _detectDirection(el, this.options);\r\n      },\r\n      ghostClass: 'sortable-ghost',\r\n      chosenClass: 'sortable-chosen',\r\n      dragClass: 'sortable-drag',\r\n      ignore: 'a, img',\r\n      filter: null,\r\n      preventOnFilter: true,\r\n      animation: 0,\r\n      easing: null,\r\n      setData: function setData(dataTransfer, dragEl) {\r\n        dataTransfer.setData('Text', dragEl.textContent);\r\n      },\r\n      dropBubble: false,\r\n      dragoverBubble: false,\r\n      dataIdAttr: 'data-id',\r\n      delay: 0,\r\n      delayOnTouchOnly: false,\r\n      touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,\r\n      forceFallback: false,\r\n      fallbackClass: 'sortable-fallback',\r\n      fallbackOnBody: false,\r\n      fallbackTolerance: 0,\r\n      fallbackOffset: {\r\n        x: 0,\r\n        y: 0\r\n      },\r\n      supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,\r\n      emptyInsertThreshold: 5\r\n    };\r\n    PluginManager.initializePlugins(this, el, defaults); // Set default options\r\n\r\n    for (var name in defaults) {\r\n      !(name in options) && (options[name] = defaults[name]);\r\n    }\r\n\r\n    _prepareGroup(options); // Bind all private methods\r\n\r\n\r\n    for (var fn in this) {\r\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\r\n        this[fn] = this[fn].bind(this);\r\n      }\r\n    } // Setup drag mode\r\n\r\n\r\n    this.nativeDraggable = options.forceFallback ? false : supportDraggable;\r\n\r\n    if (this.nativeDraggable) {\r\n      // Touch start threshold cannot be greater than the native dragstart threshold\r\n      this.options.touchStartThreshold = 1;\r\n    } // Bind events\r\n\r\n\r\n    if (options.supportPointer) {\r\n      on(el, 'pointerdown', this._onTapStart);\r\n    } else {\r\n      on(el, 'mousedown', this._onTapStart);\r\n      on(el, 'touchstart', this._onTapStart);\r\n    }\r\n\r\n    if (this.nativeDraggable) {\r\n      on(el, 'dragover', this);\r\n      on(el, 'dragenter', this);\r\n    }\r\n\r\n    sortables.push(this.el); // Restore sorting\r\n\r\n    options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager\r\n\r\n    _extends(this, AnimationStateManager());\r\n  }\r\n\r\n  Sortable.prototype =\r\n  /** @lends Sortable.prototype */\r\n  {\r\n    constructor: Sortable,\r\n    _isOutsideThisEl: function _isOutsideThisEl(target) {\r\n      if (!this.el.contains(target) && target !== this.el) {\r\n        lastTarget = null;\r\n      }\r\n    },\r\n    _getDirection: function _getDirection(evt, target) {\r\n      return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;\r\n    },\r\n    _onTapStart: function _onTapStart(\r\n    /** Event|TouchEvent */\r\n    evt) {\r\n      if (!evt.cancelable) return;\r\n\r\n      var _this = this,\r\n          el = this.el,\r\n          options = this.options,\r\n          preventOnFilter = options.preventOnFilter,\r\n          type = evt.type,\r\n          touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,\r\n          target = (touch || evt).target,\r\n          originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,\r\n          filter = options.filter;\r\n\r\n      _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\r\n\r\n\r\n      if (dragEl) {\r\n        return;\r\n      }\r\n\r\n      if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {\r\n        return; // only left button and enabled\r\n      } // cancel dnd if original target is content editable\r\n\r\n\r\n      if (originalTarget.isContentEditable) {\r\n        return;\r\n      } // Safari ignores further event handling after mousedown\r\n\r\n\r\n      if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {\r\n        return;\r\n      }\r\n\r\n      target = closest(target, options.draggable, el, false);\r\n\r\n      if (target && target.animated) {\r\n        return;\r\n      }\r\n\r\n      if (lastDownEl === target) {\r\n        // Ignoring duplicate `down`\r\n        return;\r\n      } // Get the index of the dragged element within its parent\r\n\r\n\r\n      oldIndex = index(target);\r\n      oldDraggableIndex = index(target, options.draggable); // Check filter\r\n\r\n      if (typeof filter === 'function') {\r\n        if (filter.call(this, evt, target, this)) {\r\n          _dispatchEvent({\r\n            sortable: _this,\r\n            rootEl: originalTarget,\r\n            name: 'filter',\r\n            targetEl: target,\r\n            toEl: el,\r\n            fromEl: el\r\n          });\r\n\r\n          pluginEvent('filter', _this, {\r\n            evt: evt\r\n          });\r\n          preventOnFilter && evt.cancelable && evt.preventDefault();\r\n          return; // cancel dnd\r\n        }\r\n      } else if (filter) {\r\n        filter = filter.split(',').some(function (criteria) {\r\n          criteria = closest(originalTarget, criteria.trim(), el, false);\r\n\r\n          if (criteria) {\r\n            _dispatchEvent({\r\n              sortable: _this,\r\n              rootEl: criteria,\r\n              name: 'filter',\r\n              targetEl: target,\r\n              fromEl: el,\r\n              toEl: el\r\n            });\r\n\r\n            pluginEvent('filter', _this, {\r\n              evt: evt\r\n            });\r\n            return true;\r\n          }\r\n        });\r\n\r\n        if (filter) {\r\n          preventOnFilter && evt.cancelable && evt.preventDefault();\r\n          return; // cancel dnd\r\n        }\r\n      }\r\n\r\n      if (options.handle && !closest(originalTarget, options.handle, el, false)) {\r\n        return;\r\n      } // Prepare `dragstart`\r\n\r\n\r\n      this._prepareDragStart(evt, touch, target);\r\n    },\r\n    _prepareDragStart: function _prepareDragStart(\r\n    /** Event */\r\n    evt,\r\n    /** Touch */\r\n    touch,\r\n    /** HTMLElement */\r\n    target) {\r\n      var _this = this,\r\n          el = _this.el,\r\n          options = _this.options,\r\n          ownerDocument = el.ownerDocument,\r\n          dragStartFn;\r\n\r\n      if (target && !dragEl && target.parentNode === el) {\r\n        var dragRect = getRect(target);\r\n        rootEl = el;\r\n        dragEl = target;\r\n        parentEl = dragEl.parentNode;\r\n        nextEl = dragEl.nextSibling;\r\n        lastDownEl = target;\r\n        activeGroup = options.group;\r\n        Sortable.dragged = dragEl;\r\n        tapEvt = {\r\n          target: dragEl,\r\n          clientX: (touch || evt).clientX,\r\n          clientY: (touch || evt).clientY\r\n        };\r\n        tapDistanceLeft = tapEvt.clientX - dragRect.left;\r\n        tapDistanceTop = tapEvt.clientY - dragRect.top;\r\n        this._lastX = (touch || evt).clientX;\r\n        this._lastY = (touch || evt).clientY;\r\n        dragEl.style['will-change'] = 'all';\r\n\r\n        dragStartFn = function dragStartFn() {\r\n          pluginEvent('delayEnded', _this, {\r\n            evt: evt\r\n          });\r\n\r\n          if (Sortable.eventCanceled) {\r\n            _this._onDrop();\r\n\r\n            return;\r\n          } // Delayed drag has been triggered\r\n          // we can re-enable the events: touchmove/mousemove\r\n\r\n\r\n          _this._disableDelayedDragEvents();\r\n\r\n          if (!FireFox && _this.nativeDraggable) {\r\n            dragEl.draggable = true;\r\n          } // Bind the events: dragstart/dragend\r\n\r\n\r\n          _this._triggerDragStart(evt, touch); // Drag start event\r\n\r\n\r\n          _dispatchEvent({\r\n            sortable: _this,\r\n            name: 'choose',\r\n            originalEvent: evt\r\n          }); // Chosen item\r\n\r\n\r\n          toggleClass(dragEl, options.chosenClass, true);\r\n        }; // Disable \"draggable\"\r\n\r\n\r\n        options.ignore.split(',').forEach(function (criteria) {\r\n          find(dragEl, criteria.trim(), _disableDraggable);\r\n        });\r\n        on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);\r\n        on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);\r\n        on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);\r\n        on(ownerDocument, 'mouseup', _this._onDrop);\r\n        on(ownerDocument, 'touchend', _this._onDrop);\r\n        on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)\r\n\r\n        if (FireFox && this.nativeDraggable) {\r\n          this.options.touchStartThreshold = 4;\r\n          dragEl.draggable = true;\r\n        }\r\n\r\n        pluginEvent('delayStart', this, {\r\n          evt: evt\r\n        }); // Delay is impossible for native DnD in Edge or IE\r\n\r\n        if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {\r\n          if (Sortable.eventCanceled) {\r\n            this._onDrop();\r\n\r\n            return;\r\n          } // If the user moves the pointer or let go the click or touch\r\n          // before the delay has been reached:\r\n          // disable the delayed drag\r\n\r\n\r\n          on(ownerDocument, 'mouseup', _this._disableDelayedDrag);\r\n          on(ownerDocument, 'touchend', _this._disableDelayedDrag);\r\n          on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);\r\n          on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);\r\n          on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);\r\n          options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);\r\n          _this._dragStartTimer = setTimeout(dragStartFn, options.delay);\r\n        } else {\r\n          dragStartFn();\r\n        }\r\n      }\r\n    },\r\n    _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(\r\n    /** TouchEvent|PointerEvent **/\r\n    e) {\r\n      var touch = e.touches ? e.touches[0] : e;\r\n\r\n      if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {\r\n        this._disableDelayedDrag();\r\n      }\r\n    },\r\n    _disableDelayedDrag: function _disableDelayedDrag() {\r\n      dragEl && _disableDraggable(dragEl);\r\n      clearTimeout(this._dragStartTimer);\r\n\r\n      this._disableDelayedDragEvents();\r\n    },\r\n    _disableDelayedDragEvents: function _disableDelayedDragEvents() {\r\n      var ownerDocument = this.el.ownerDocument;\r\n      off(ownerDocument, 'mouseup', this._disableDelayedDrag);\r\n      off(ownerDocument, 'touchend', this._disableDelayedDrag);\r\n      off(ownerDocument, 'touchcancel', this._disableDelayedDrag);\r\n      off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);\r\n      off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);\r\n      off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);\r\n    },\r\n    _triggerDragStart: function _triggerDragStart(\r\n    /** Event */\r\n    evt,\r\n    /** Touch */\r\n    touch) {\r\n      touch = touch || evt.pointerType == 'touch' && evt;\r\n\r\n      if (!this.nativeDraggable || touch) {\r\n        if (this.options.supportPointer) {\r\n          on(document, 'pointermove', this._onTouchMove);\r\n        } else if (touch) {\r\n          on(document, 'touchmove', this._onTouchMove);\r\n        } else {\r\n          on(document, 'mousemove', this._onTouchMove);\r\n        }\r\n      } else {\r\n        on(dragEl, 'dragend', this);\r\n        on(rootEl, 'dragstart', this._onDragStart);\r\n      }\r\n\r\n      try {\r\n        if (document.selection) {\r\n          // Timeout neccessary for IE9\r\n          _nextTick(function () {\r\n            document.selection.empty();\r\n          });\r\n        } else {\r\n          window.getSelection().removeAllRanges();\r\n        }\r\n      } catch (err) {}\r\n    },\r\n    _dragStarted: function _dragStarted(fallback, evt) {\r\n\r\n      awaitingDragStarted = false;\r\n\r\n      if (rootEl && dragEl) {\r\n        pluginEvent('dragStarted', this, {\r\n          evt: evt\r\n        });\r\n\r\n        if (this.nativeDraggable) {\r\n          on(document, 'dragover', _checkOutsideTargetEl);\r\n        }\r\n\r\n        var options = this.options; // Apply effect\r\n\r\n        !fallback && toggleClass(dragEl, options.dragClass, false);\r\n        toggleClass(dragEl, options.ghostClass, true);\r\n        Sortable.active = this;\r\n        fallback && this._appendGhost(); // Drag start event\r\n\r\n        _dispatchEvent({\r\n          sortable: this,\r\n          name: 'start',\r\n          originalEvent: evt\r\n        });\r\n      } else {\r\n        this._nulling();\r\n      }\r\n    },\r\n    _emulateDragOver: function _emulateDragOver() {\r\n      if (touchEvt) {\r\n        this._lastX = touchEvt.clientX;\r\n        this._lastY = touchEvt.clientY;\r\n\r\n        _hideGhostForTarget();\r\n\r\n        var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\r\n        var parent = target;\r\n\r\n        while (target && target.shadowRoot) {\r\n          target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\r\n          if (target === parent) break;\r\n          parent = target;\r\n        }\r\n\r\n        dragEl.parentNode[expando]._isOutsideThisEl(target);\r\n\r\n        if (parent) {\r\n          do {\r\n            if (parent[expando]) {\r\n              var inserted = void 0;\r\n              inserted = parent[expando]._onDragOver({\r\n                clientX: touchEvt.clientX,\r\n                clientY: touchEvt.clientY,\r\n                target: target,\r\n                rootEl: parent\r\n              });\r\n\r\n              if (inserted && !this.options.dragoverBubble) {\r\n                break;\r\n              }\r\n            }\r\n\r\n            target = parent; // store last element\r\n          }\r\n          /* jshint boss:true */\r\n          while (parent = parent.parentNode);\r\n        }\r\n\r\n        _unhideGhostForTarget();\r\n      }\r\n    },\r\n    _onTouchMove: function _onTouchMove(\r\n    /**TouchEvent*/\r\n    evt) {\r\n      if (tapEvt) {\r\n        var options = this.options,\r\n            fallbackTolerance = options.fallbackTolerance,\r\n            fallbackOffset = options.fallbackOffset,\r\n            touch = evt.touches ? evt.touches[0] : evt,\r\n            ghostMatrix = ghostEl && matrix(ghostEl, true),\r\n            scaleX = ghostEl && ghostMatrix && ghostMatrix.a,\r\n            scaleY = ghostEl && ghostMatrix && ghostMatrix.d,\r\n            relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),\r\n            dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),\r\n            dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging\r\n\r\n        if (!Sortable.active && !awaitingDragStarted) {\r\n          if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {\r\n            return;\r\n          }\r\n\r\n          this._onDragStart(evt, true);\r\n        }\r\n\r\n        if (ghostEl) {\r\n          if (ghostMatrix) {\r\n            ghostMatrix.e += dx - (lastDx || 0);\r\n            ghostMatrix.f += dy - (lastDy || 0);\r\n          } else {\r\n            ghostMatrix = {\r\n              a: 1,\r\n              b: 0,\r\n              c: 0,\r\n              d: 1,\r\n              e: dx,\r\n              f: dy\r\n            };\r\n          }\r\n\r\n          var cssMatrix = \"matrix(\".concat(ghostMatrix.a, \",\").concat(ghostMatrix.b, \",\").concat(ghostMatrix.c, \",\").concat(ghostMatrix.d, \",\").concat(ghostMatrix.e, \",\").concat(ghostMatrix.f, \")\");\r\n          css(ghostEl, 'webkitTransform', cssMatrix);\r\n          css(ghostEl, 'mozTransform', cssMatrix);\r\n          css(ghostEl, 'msTransform', cssMatrix);\r\n          css(ghostEl, 'transform', cssMatrix);\r\n          lastDx = dx;\r\n          lastDy = dy;\r\n          touchEvt = touch;\r\n        }\r\n\r\n        evt.cancelable && evt.preventDefault();\r\n      }\r\n    },\r\n    _appendGhost: function _appendGhost() {\r\n      // Bug if using scale(): https://stackoverflow.com/questions/2637058\r\n      // Not being adjusted for\r\n      if (!ghostEl) {\r\n        var container = this.options.fallbackOnBody ? document.body : rootEl,\r\n            rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),\r\n            options = this.options; // Position absolutely\r\n\r\n        if (PositionGhostAbsolutely) {\r\n          // Get relatively positioned parent\r\n          ghostRelativeParent = container;\r\n\r\n          while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {\r\n            ghostRelativeParent = ghostRelativeParent.parentNode;\r\n          }\r\n\r\n          if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {\r\n            if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();\r\n            rect.top += ghostRelativeParent.scrollTop;\r\n            rect.left += ghostRelativeParent.scrollLeft;\r\n          } else {\r\n            ghostRelativeParent = getWindowScrollingElement();\r\n          }\r\n\r\n          ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);\r\n        }\r\n\r\n        ghostEl = dragEl.cloneNode(true);\r\n        toggleClass(ghostEl, options.ghostClass, false);\r\n        toggleClass(ghostEl, options.fallbackClass, true);\r\n        toggleClass(ghostEl, options.dragClass, true);\r\n        css(ghostEl, 'transition', '');\r\n        css(ghostEl, 'transform', '');\r\n        css(ghostEl, 'box-sizing', 'border-box');\r\n        css(ghostEl, 'margin', 0);\r\n        css(ghostEl, 'top', rect.top);\r\n        css(ghostEl, 'left', rect.left);\r\n        css(ghostEl, 'width', rect.width);\r\n        css(ghostEl, 'height', rect.height);\r\n        css(ghostEl, 'opacity', '0.8');\r\n        css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');\r\n        css(ghostEl, 'zIndex', '100000');\r\n        css(ghostEl, 'pointerEvents', 'none');\r\n        Sortable.ghost = ghostEl;\r\n        container.appendChild(ghostEl); // Set transform-origin\r\n\r\n        css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');\r\n      }\r\n    },\r\n    _onDragStart: function _onDragStart(\r\n    /**Event*/\r\n    evt,\r\n    /**boolean*/\r\n    fallback) {\r\n      var _this = this;\r\n\r\n      var dataTransfer = evt.dataTransfer;\r\n      var options = _this.options;\r\n      pluginEvent('dragStart', this, {\r\n        evt: evt\r\n      });\r\n\r\n      if (Sortable.eventCanceled) {\r\n        this._onDrop();\r\n\r\n        return;\r\n      }\r\n\r\n      pluginEvent('setupClone', this);\r\n\r\n      if (!Sortable.eventCanceled) {\r\n        cloneEl = clone(dragEl);\r\n        cloneEl.removeAttribute(\"id\");\r\n        cloneEl.draggable = false;\r\n        cloneEl.style['will-change'] = '';\r\n\r\n        this._hideClone();\r\n\r\n        toggleClass(cloneEl, this.options.chosenClass, false);\r\n        Sortable.clone = cloneEl;\r\n      } // #1143: IFrame support workaround\r\n\r\n\r\n      _this.cloneId = _nextTick(function () {\r\n        pluginEvent('clone', _this);\r\n        if (Sortable.eventCanceled) return;\r\n\r\n        if (!_this.options.removeCloneOnHide) {\r\n          rootEl.insertBefore(cloneEl, dragEl);\r\n        }\r\n\r\n        _this._hideClone();\r\n\r\n        _dispatchEvent({\r\n          sortable: _this,\r\n          name: 'clone'\r\n        });\r\n      });\r\n      !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events\r\n\r\n      if (fallback) {\r\n        ignoreNextClick = true;\r\n        _this._loopId = setInterval(_this._emulateDragOver, 50);\r\n      } else {\r\n        // Undo what was set in _prepareDragStart before drag started\r\n        off(document, 'mouseup', _this._onDrop);\r\n        off(document, 'touchend', _this._onDrop);\r\n        off(document, 'touchcancel', _this._onDrop);\r\n\r\n        if (dataTransfer) {\r\n          dataTransfer.effectAllowed = 'move';\r\n          options.setData && options.setData.call(_this, dataTransfer, dragEl);\r\n        }\r\n\r\n        on(document, 'drop', _this); // #1276 fix:\r\n\r\n        css(dragEl, 'transform', 'translateZ(0)');\r\n      }\r\n\r\n      awaitingDragStarted = true;\r\n      _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));\r\n      on(document, 'selectstart', _this);\r\n      moved = true;\r\n\r\n      if (Safari) {\r\n        css(document.body, 'user-select', 'none');\r\n      }\r\n    },\r\n    // Returns true - if no further action is needed (either inserted or another condition)\r\n    _onDragOver: function _onDragOver(\r\n    /**Event*/\r\n    evt) {\r\n      var el = this.el,\r\n          target = evt.target,\r\n          dragRect,\r\n          targetRect,\r\n          revert,\r\n          options = this.options,\r\n          group = options.group,\r\n          activeSortable = Sortable.active,\r\n          isOwner = activeGroup === group,\r\n          canSort = options.sort,\r\n          fromSortable = putSortable || activeSortable,\r\n          vertical,\r\n          _this = this,\r\n          completedFired = false;\r\n\r\n      if (_silent) return;\r\n\r\n      function dragOverEvent(name, extra) {\r\n        pluginEvent(name, _this, _objectSpread2({\r\n          evt: evt,\r\n          isOwner: isOwner,\r\n          axis: vertical ? 'vertical' : 'horizontal',\r\n          revert: revert,\r\n          dragRect: dragRect,\r\n          targetRect: targetRect,\r\n          canSort: canSort,\r\n          fromSortable: fromSortable,\r\n          target: target,\r\n          completed: completed,\r\n          onMove: function onMove(target, after) {\r\n            return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);\r\n          },\r\n          changed: changed\r\n        }, extra));\r\n      } // Capture animation state\r\n\r\n\r\n      function capture() {\r\n        dragOverEvent('dragOverAnimationCapture');\r\n\r\n        _this.captureAnimationState();\r\n\r\n        if (_this !== fromSortable) {\r\n          fromSortable.captureAnimationState();\r\n        }\r\n      } // Return invocation when dragEl is inserted (or completed)\r\n\r\n\r\n      function completed(insertion) {\r\n        dragOverEvent('dragOverCompleted', {\r\n          insertion: insertion\r\n        });\r\n\r\n        if (insertion) {\r\n          // Clones must be hidden before folding animation to capture dragRectAbsolute properly\r\n          if (isOwner) {\r\n            activeSortable._hideClone();\r\n          } else {\r\n            activeSortable._showClone(_this);\r\n          }\r\n\r\n          if (_this !== fromSortable) {\r\n            // Set ghost class to new sortable's ghost class\r\n            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);\r\n            toggleClass(dragEl, options.ghostClass, true);\r\n          }\r\n\r\n          if (putSortable !== _this && _this !== Sortable.active) {\r\n            putSortable = _this;\r\n          } else if (_this === Sortable.active && putSortable) {\r\n            putSortable = null;\r\n          } // Animation\r\n\r\n\r\n          if (fromSortable === _this) {\r\n            _this._ignoreWhileAnimating = target;\r\n          }\r\n\r\n          _this.animateAll(function () {\r\n            dragOverEvent('dragOverAnimationComplete');\r\n            _this._ignoreWhileAnimating = null;\r\n          });\r\n\r\n          if (_this !== fromSortable) {\r\n            fromSortable.animateAll();\r\n            fromSortable._ignoreWhileAnimating = null;\r\n          }\r\n        } // Null lastTarget if it is not inside a previously swapped element\r\n\r\n\r\n        if (target === dragEl && !dragEl.animated || target === el && !target.animated) {\r\n          lastTarget = null;\r\n        } // no bubbling and not fallback\r\n\r\n\r\n        if (!options.dragoverBubble && !evt.rootEl && target !== document) {\r\n          dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted\r\n\r\n\r\n          !insertion && nearestEmptyInsertDetectEvent(evt);\r\n        }\r\n\r\n        !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\r\n        return completedFired = true;\r\n      } // Call when dragEl has been inserted\r\n\r\n\r\n      function changed() {\r\n        newIndex = index(dragEl);\r\n        newDraggableIndex = index(dragEl, options.draggable);\r\n\r\n        _dispatchEvent({\r\n          sortable: _this,\r\n          name: 'change',\r\n          toEl: el,\r\n          newIndex: newIndex,\r\n          newDraggableIndex: newDraggableIndex,\r\n          originalEvent: evt\r\n        });\r\n      }\r\n\r\n      if (evt.preventDefault !== void 0) {\r\n        evt.cancelable && evt.preventDefault();\r\n      }\r\n\r\n      target = closest(target, options.draggable, el, true);\r\n      dragOverEvent('dragOver');\r\n      if (Sortable.eventCanceled) return completedFired;\r\n\r\n      if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {\r\n        return completed(false);\r\n      }\r\n\r\n      ignoreNextClick = false;\r\n\r\n      if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list\r\n      : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {\r\n        vertical = this._getDirection(evt, target) === 'vertical';\r\n        dragRect = getRect(dragEl);\r\n        dragOverEvent('dragOverValid');\r\n        if (Sortable.eventCanceled) return completedFired;\r\n\r\n        if (revert) {\r\n          parentEl = rootEl; // actualization\r\n\r\n          capture();\r\n\r\n          this._hideClone();\r\n\r\n          dragOverEvent('revert');\r\n\r\n          if (!Sortable.eventCanceled) {\r\n            if (nextEl) {\r\n              rootEl.insertBefore(dragEl, nextEl);\r\n            } else {\r\n              rootEl.appendChild(dragEl);\r\n            }\r\n          }\r\n\r\n          return completed(true);\r\n        }\r\n\r\n        var elLastChild = lastChild(el, options.draggable);\r\n\r\n        if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {\r\n          // Insert to end of list\r\n          // If already at end of list: Do not insert\r\n          if (elLastChild === dragEl) {\r\n            return completed(false);\r\n          } // if there is a last element, it is the target\r\n\r\n\r\n          if (elLastChild && el === evt.target) {\r\n            target = elLastChild;\r\n          }\r\n\r\n          if (target) {\r\n            targetRect = getRect(target);\r\n          }\r\n\r\n          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {\r\n            capture();\r\n\r\n            if (elLastChild && elLastChild.nextSibling) {\r\n              // the last draggable element is not the last node\r\n              el.insertBefore(dragEl, elLastChild.nextSibling);\r\n            } else {\r\n              el.appendChild(dragEl);\r\n            }\r\n\r\n            parentEl = el; // actualization\r\n\r\n            changed();\r\n            return completed(true);\r\n          }\r\n        } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {\r\n          // Insert to start of list\r\n          var firstChild = getChild(el, 0, options, true);\r\n\r\n          if (firstChild === dragEl) {\r\n            return completed(false);\r\n          }\r\n\r\n          target = firstChild;\r\n          targetRect = getRect(target);\r\n\r\n          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {\r\n            capture();\r\n            el.insertBefore(dragEl, firstChild);\r\n            parentEl = el; // actualization\r\n\r\n            changed();\r\n            return completed(true);\r\n          }\r\n        } else if (target.parentNode === el) {\r\n          targetRect = getRect(target);\r\n          var direction = 0,\r\n              targetBeforeFirstSwap,\r\n              differentLevel = dragEl.parentNode !== el,\r\n              differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),\r\n              side1 = vertical ? 'top' : 'left',\r\n              scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),\r\n              scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\r\n\r\n          if (lastTarget !== target) {\r\n            targetBeforeFirstSwap = targetRect[side1];\r\n            pastFirstInvertThresh = false;\r\n            isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;\r\n          }\r\n\r\n          direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);\r\n          var sibling;\r\n\r\n          if (direction !== 0) {\r\n            // Check if target is beside dragEl in respective direction (ignoring hidden elements)\r\n            var dragIndex = index(dragEl);\r\n\r\n            do {\r\n              dragIndex -= direction;\r\n              sibling = parentEl.children[dragIndex];\r\n            } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));\r\n          } // If dragEl is already beside target: Do not insert\r\n\r\n\r\n          if (direction === 0 || sibling === target) {\r\n            return completed(false);\r\n          }\r\n\r\n          lastTarget = target;\r\n          lastDirection = direction;\r\n          var nextSibling = target.nextElementSibling,\r\n              after = false;\r\n          after = direction === 1;\r\n\r\n          var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);\r\n\r\n          if (moveVector !== false) {\r\n            if (moveVector === 1 || moveVector === -1) {\r\n              after = moveVector === 1;\r\n            }\r\n\r\n            _silent = true;\r\n            setTimeout(_unsilent, 30);\r\n            capture();\r\n\r\n            if (after && !nextSibling) {\r\n              el.appendChild(dragEl);\r\n            } else {\r\n              target.parentNode.insertBefore(dragEl, after ? nextSibling : target);\r\n            } // Undo chrome's scroll adjustment (has no effect on other browsers)\r\n\r\n\r\n            if (scrolledPastTop) {\r\n              scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);\r\n            }\r\n\r\n            parentEl = dragEl.parentNode; // actualization\r\n            // must be done before animation\r\n\r\n            if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\r\n              targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);\r\n            }\r\n\r\n            changed();\r\n            return completed(true);\r\n          }\r\n        }\r\n\r\n        if (el.contains(dragEl)) {\r\n          return completed(false);\r\n        }\r\n      }\r\n\r\n      return false;\r\n    },\r\n    _ignoreWhileAnimating: null,\r\n    _offMoveEvents: function _offMoveEvents() {\r\n      off(document, 'mousemove', this._onTouchMove);\r\n      off(document, 'touchmove', this._onTouchMove);\r\n      off(document, 'pointermove', this._onTouchMove);\r\n      off(document, 'dragover', nearestEmptyInsertDetectEvent);\r\n      off(document, 'mousemove', nearestEmptyInsertDetectEvent);\r\n      off(document, 'touchmove', nearestEmptyInsertDetectEvent);\r\n    },\r\n    _offUpEvents: function _offUpEvents() {\r\n      var ownerDocument = this.el.ownerDocument;\r\n      off(ownerDocument, 'mouseup', this._onDrop);\r\n      off(ownerDocument, 'touchend', this._onDrop);\r\n      off(ownerDocument, 'pointerup', this._onDrop);\r\n      off(ownerDocument, 'touchcancel', this._onDrop);\r\n      off(document, 'selectstart', this);\r\n    },\r\n    _onDrop: function _onDrop(\r\n    /**Event*/\r\n    evt) {\r\n      var el = this.el,\r\n          options = this.options; // Get the index of the dragged element within its parent\r\n\r\n      newIndex = index(dragEl);\r\n      newDraggableIndex = index(dragEl, options.draggable);\r\n      pluginEvent('drop', this, {\r\n        evt: evt\r\n      });\r\n      parentEl = dragEl && dragEl.parentNode; // Get again after plugin event\r\n\r\n      newIndex = index(dragEl);\r\n      newDraggableIndex = index(dragEl, options.draggable);\r\n\r\n      if (Sortable.eventCanceled) {\r\n        this._nulling();\r\n\r\n        return;\r\n      }\r\n\r\n      awaitingDragStarted = false;\r\n      isCircumstantialInvert = false;\r\n      pastFirstInvertThresh = false;\r\n      clearInterval(this._loopId);\r\n      clearTimeout(this._dragStartTimer);\r\n\r\n      _cancelNextTick(this.cloneId);\r\n\r\n      _cancelNextTick(this._dragStartId); // Unbind events\r\n\r\n\r\n      if (this.nativeDraggable) {\r\n        off(document, 'drop', this);\r\n        off(el, 'dragstart', this._onDragStart);\r\n      }\r\n\r\n      this._offMoveEvents();\r\n\r\n      this._offUpEvents();\r\n\r\n      if (Safari) {\r\n        css(document.body, 'user-select', '');\r\n      }\r\n\r\n      css(dragEl, 'transform', '');\r\n\r\n      if (evt) {\r\n        if (moved) {\r\n          evt.cancelable && evt.preventDefault();\r\n          !options.dropBubble && evt.stopPropagation();\r\n        }\r\n\r\n        ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\r\n\r\n        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\r\n          // Remove clone(s)\r\n          cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);\r\n        }\r\n\r\n        if (dragEl) {\r\n          if (this.nativeDraggable) {\r\n            off(dragEl, 'dragend', this);\r\n          }\r\n\r\n          _disableDraggable(dragEl);\r\n\r\n          dragEl.style['will-change'] = ''; // Remove classes\r\n          // ghostClass is added in dragStarted\r\n\r\n          if (moved && !awaitingDragStarted) {\r\n            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);\r\n          }\r\n\r\n          toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event\r\n\r\n          _dispatchEvent({\r\n            sortable: this,\r\n            name: 'unchoose',\r\n            toEl: parentEl,\r\n            newIndex: null,\r\n            newDraggableIndex: null,\r\n            originalEvent: evt\r\n          });\r\n\r\n          if (rootEl !== parentEl) {\r\n            if (newIndex >= 0) {\r\n              // Add event\r\n              _dispatchEvent({\r\n                rootEl: parentEl,\r\n                name: 'add',\r\n                toEl: parentEl,\r\n                fromEl: rootEl,\r\n                originalEvent: evt\r\n              }); // Remove event\r\n\r\n\r\n              _dispatchEvent({\r\n                sortable: this,\r\n                name: 'remove',\r\n                toEl: parentEl,\r\n                originalEvent: evt\r\n              }); // drag from one list and drop into another\r\n\r\n\r\n              _dispatchEvent({\r\n                rootEl: parentEl,\r\n                name: 'sort',\r\n                toEl: parentEl,\r\n                fromEl: rootEl,\r\n                originalEvent: evt\r\n              });\r\n\r\n              _dispatchEvent({\r\n                sortable: this,\r\n                name: 'sort',\r\n                toEl: parentEl,\r\n                originalEvent: evt\r\n              });\r\n            }\r\n\r\n            putSortable && putSortable.save();\r\n          } else {\r\n            if (newIndex !== oldIndex) {\r\n              if (newIndex >= 0) {\r\n                // drag & drop within the same list\r\n                _dispatchEvent({\r\n                  sortable: this,\r\n                  name: 'update',\r\n                  toEl: parentEl,\r\n                  originalEvent: evt\r\n                });\r\n\r\n                _dispatchEvent({\r\n                  sortable: this,\r\n                  name: 'sort',\r\n                  toEl: parentEl,\r\n                  originalEvent: evt\r\n                });\r\n              }\r\n            }\r\n          }\r\n\r\n          if (Sortable.active) {\r\n            /* jshint eqnull:true */\r\n            if (newIndex == null || newIndex === -1) {\r\n              newIndex = oldIndex;\r\n              newDraggableIndex = oldDraggableIndex;\r\n            }\r\n\r\n            _dispatchEvent({\r\n              sortable: this,\r\n              name: 'end',\r\n              toEl: parentEl,\r\n              originalEvent: evt\r\n            }); // Save sorting\r\n\r\n\r\n            this.save();\r\n          }\r\n        }\r\n      }\r\n\r\n      this._nulling();\r\n    },\r\n    _nulling: function _nulling() {\r\n      pluginEvent('nulling', this);\r\n      rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;\r\n      savedInputChecked.forEach(function (el) {\r\n        el.checked = true;\r\n      });\r\n      savedInputChecked.length = lastDx = lastDy = 0;\r\n    },\r\n    handleEvent: function handleEvent(\r\n    /**Event*/\r\n    evt) {\r\n      switch (evt.type) {\r\n        case 'drop':\r\n        case 'dragend':\r\n          this._onDrop(evt);\r\n\r\n          break;\r\n\r\n        case 'dragenter':\r\n        case 'dragover':\r\n          if (dragEl) {\r\n            this._onDragOver(evt);\r\n\r\n            _globalDragOver(evt);\r\n          }\r\n\r\n          break;\r\n\r\n        case 'selectstart':\r\n          evt.preventDefault();\r\n          break;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Serializes the item into an array of string.\r\n     * @returns {String[]}\r\n     */\r\n    toArray: function toArray() {\r\n      var order = [],\r\n          el,\r\n          children = this.el.children,\r\n          i = 0,\r\n          n = children.length,\r\n          options = this.options;\r\n\r\n      for (; i < n; i++) {\r\n        el = children[i];\r\n\r\n        if (closest(el, options.draggable, this.el, false)) {\r\n          order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\r\n        }\r\n      }\r\n\r\n      return order;\r\n    },\r\n\r\n    /**\r\n     * Sorts the elements according to the array.\r\n     * @param  {String[]}  order  order of the items\r\n     */\r\n    sort: function sort(order, useAnimation) {\r\n      var items = {},\r\n          rootEl = this.el;\r\n      this.toArray().forEach(function (id, i) {\r\n        var el = rootEl.children[i];\r\n\r\n        if (closest(el, this.options.draggable, rootEl, false)) {\r\n          items[id] = el;\r\n        }\r\n      }, this);\r\n      useAnimation && this.captureAnimationState();\r\n      order.forEach(function (id) {\r\n        if (items[id]) {\r\n          rootEl.removeChild(items[id]);\r\n          rootEl.appendChild(items[id]);\r\n        }\r\n      });\r\n      useAnimation && this.animateAll();\r\n    },\r\n\r\n    /**\r\n     * Save the current sorting\r\n     */\r\n    save: function save() {\r\n      var store = this.options.store;\r\n      store && store.set && store.set(this);\r\n    },\r\n\r\n    /**\r\n     * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\r\n     * @param   {HTMLElement}  el\r\n     * @param   {String}       [selector]  default: `options.draggable`\r\n     * @returns {HTMLElement|null}\r\n     */\r\n    closest: function closest$1(el, selector) {\r\n      return closest(el, selector || this.options.draggable, this.el, false);\r\n    },\r\n\r\n    /**\r\n     * Set/get option\r\n     * @param   {string} name\r\n     * @param   {*}      [value]\r\n     * @returns {*}\r\n     */\r\n    option: function option(name, value) {\r\n      var options = this.options;\r\n\r\n      if (value === void 0) {\r\n        return options[name];\r\n      } else {\r\n        var modifiedValue = PluginManager.modifyOption(this, name, value);\r\n\r\n        if (typeof modifiedValue !== 'undefined') {\r\n          options[name] = modifiedValue;\r\n        } else {\r\n          options[name] = value;\r\n        }\r\n\r\n        if (name === 'group') {\r\n          _prepareGroup(options);\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Destroy\r\n     */\r\n    destroy: function destroy() {\r\n      pluginEvent('destroy', this);\r\n      var el = this.el;\r\n      el[expando] = null;\r\n      off(el, 'mousedown', this._onTapStart);\r\n      off(el, 'touchstart', this._onTapStart);\r\n      off(el, 'pointerdown', this._onTapStart);\r\n\r\n      if (this.nativeDraggable) {\r\n        off(el, 'dragover', this);\r\n        off(el, 'dragenter', this);\r\n      } // Remove draggable attributes\r\n\r\n\r\n      Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {\r\n        el.removeAttribute('draggable');\r\n      });\r\n\r\n      this._onDrop();\r\n\r\n      this._disableDelayedDragEvents();\r\n\r\n      sortables.splice(sortables.indexOf(this.el), 1);\r\n      this.el = el = null;\r\n    },\r\n    _hideClone: function _hideClone() {\r\n      if (!cloneHidden) {\r\n        pluginEvent('hideClone', this);\r\n        if (Sortable.eventCanceled) return;\r\n        css(cloneEl, 'display', 'none');\r\n\r\n        if (this.options.removeCloneOnHide && cloneEl.parentNode) {\r\n          cloneEl.parentNode.removeChild(cloneEl);\r\n        }\r\n\r\n        cloneHidden = true;\r\n      }\r\n    },\r\n    _showClone: function _showClone(putSortable) {\r\n      if (putSortable.lastPutMode !== 'clone') {\r\n        this._hideClone();\r\n\r\n        return;\r\n      }\r\n\r\n      if (cloneHidden) {\r\n        pluginEvent('showClone', this);\r\n        if (Sortable.eventCanceled) return; // show clone at dragEl or original position\r\n\r\n        if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {\r\n          rootEl.insertBefore(cloneEl, dragEl);\r\n        } else if (nextEl) {\r\n          rootEl.insertBefore(cloneEl, nextEl);\r\n        } else {\r\n          rootEl.appendChild(cloneEl);\r\n        }\r\n\r\n        if (this.options.group.revertClone) {\r\n          this.animate(dragEl, cloneEl);\r\n        }\r\n\r\n        css(cloneEl, 'display', '');\r\n        cloneHidden = false;\r\n      }\r\n    }\r\n  };\r\n\r\n  function _globalDragOver(\r\n  /**Event*/\r\n  evt) {\r\n    if (evt.dataTransfer) {\r\n      evt.dataTransfer.dropEffect = 'move';\r\n    }\r\n\r\n    evt.cancelable && evt.preventDefault();\r\n  }\r\n\r\n  function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {\r\n    var evt,\r\n        sortable = fromEl[expando],\r\n        onMoveFn = sortable.options.onMove,\r\n        retVal; // Support for new CustomEvent feature\r\n\r\n    if (window.CustomEvent && !IE11OrLess && !Edge) {\r\n      evt = new CustomEvent('move', {\r\n        bubbles: true,\r\n        cancelable: true\r\n      });\r\n    } else {\r\n      evt = document.createEvent('Event');\r\n      evt.initEvent('move', true, true);\r\n    }\r\n\r\n    evt.to = toEl;\r\n    evt.from = fromEl;\r\n    evt.dragged = dragEl;\r\n    evt.draggedRect = dragRect;\r\n    evt.related = targetEl || toEl;\r\n    evt.relatedRect = targetRect || getRect(toEl);\r\n    evt.willInsertAfter = willInsertAfter;\r\n    evt.originalEvent = originalEvent;\r\n    fromEl.dispatchEvent(evt);\r\n\r\n    if (onMoveFn) {\r\n      retVal = onMoveFn.call(sortable, evt, originalEvent);\r\n    }\r\n\r\n    return retVal;\r\n  }\r\n\r\n  function _disableDraggable(el) {\r\n    el.draggable = false;\r\n  }\r\n\r\n  function _unsilent() {\r\n    _silent = false;\r\n  }\r\n\r\n  function _ghostIsFirst(evt, vertical, sortable) {\r\n    var rect = getRect(getChild(sortable.el, 0, sortable.options, true));\r\n    var spacer = 10;\r\n    return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;\r\n  }\r\n\r\n  function _ghostIsLast(evt, vertical, sortable) {\r\n    var rect = getRect(lastChild(sortable.el, sortable.options.draggable));\r\n    var spacer = 10;\r\n    return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;\r\n  }\r\n\r\n  function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {\r\n    var mouseOnAxis = vertical ? evt.clientY : evt.clientX,\r\n        targetLength = vertical ? targetRect.height : targetRect.width,\r\n        targetS1 = vertical ? targetRect.top : targetRect.left,\r\n        targetS2 = vertical ? targetRect.bottom : targetRect.right,\r\n        invert = false;\r\n\r\n    if (!invertSwap) {\r\n      // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\r\n      if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {\r\n        // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\r\n        // check if past first invert threshold on side opposite of lastDirection\r\n        if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {\r\n          // past first invert threshold, do not restrict inverted threshold to dragEl shadow\r\n          pastFirstInvertThresh = true;\r\n        }\r\n\r\n        if (!pastFirstInvertThresh) {\r\n          // dragEl shadow (target move distance shadow)\r\n          if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\r\n          : mouseOnAxis > targetS2 - targetMoveDistance) {\r\n            return -lastDirection;\r\n          }\r\n        } else {\r\n          invert = true;\r\n        }\r\n      } else {\r\n        // Regular\r\n        if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {\r\n          return _getInsertDirection(target);\r\n        }\r\n      }\r\n    }\r\n\r\n    invert = invert || invertSwap;\r\n\r\n    if (invert) {\r\n      // Invert of regular\r\n      if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {\r\n        return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;\r\n      }\r\n    }\r\n\r\n    return 0;\r\n  }\r\n  /**\r\n   * Gets the direction dragEl must be swapped relative to target in order to make it\r\n   * seem that dragEl has been \"inserted\" into that element's position\r\n   * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\r\n   * @return {Number}                   Direction dragEl must be swapped\r\n   */\r\n\r\n\r\n  function _getInsertDirection(target) {\r\n    if (index(dragEl) < index(target)) {\r\n      return 1;\r\n    } else {\r\n      return -1;\r\n    }\r\n  }\r\n  /**\r\n   * Generate id\r\n   * @param   {HTMLElement} el\r\n   * @returns {String}\r\n   * @private\r\n   */\r\n\r\n\r\n  function _generateId(el) {\r\n    var str = el.tagName + el.className + el.src + el.href + el.textContent,\r\n        i = str.length,\r\n        sum = 0;\r\n\r\n    while (i--) {\r\n      sum += str.charCodeAt(i);\r\n    }\r\n\r\n    return sum.toString(36);\r\n  }\r\n\r\n  function _saveInputCheckedState(root) {\r\n    savedInputChecked.length = 0;\r\n    var inputs = root.getElementsByTagName('input');\r\n    var idx = inputs.length;\r\n\r\n    while (idx--) {\r\n      var el = inputs[idx];\r\n      el.checked && savedInputChecked.push(el);\r\n    }\r\n  }\r\n\r\n  function _nextTick(fn) {\r\n    return setTimeout(fn, 0);\r\n  }\r\n\r\n  function _cancelNextTick(id) {\r\n    return clearTimeout(id);\r\n  } // Fixed #973:\r\n\r\n\r\n  if (documentExists) {\r\n    on(document, 'touchmove', function (evt) {\r\n      if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {\r\n        evt.preventDefault();\r\n      }\r\n    });\r\n  } // Export utils\r\n\r\n\r\n  Sortable.utils = {\r\n    on: on,\r\n    off: off,\r\n    css: css,\r\n    find: find,\r\n    is: function is(el, selector) {\r\n      return !!closest(el, selector, el, false);\r\n    },\r\n    extend: extend,\r\n    throttle: throttle,\r\n    closest: closest,\r\n    toggleClass: toggleClass,\r\n    clone: clone,\r\n    index: index,\r\n    nextTick: _nextTick,\r\n    cancelNextTick: _cancelNextTick,\r\n    detectDirection: _detectDirection,\r\n    getChild: getChild\r\n  };\r\n  /**\r\n   * Get the Sortable instance of an element\r\n   * @param  {HTMLElement} element The element\r\n   * @return {Sortable|undefined}         The instance of Sortable\r\n   */\r\n\r\n  Sortable.get = function (element) {\r\n    return element[expando];\r\n  };\r\n  /**\r\n   * Mount a plugin to Sortable\r\n   * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted\r\n   */\r\n\r\n\r\n  Sortable.mount = function () {\r\n    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      plugins[_key] = arguments[_key];\r\n    }\r\n\r\n    if (plugins[0].constructor === Array) plugins = plugins[0];\r\n    plugins.forEach(function (plugin) {\r\n      if (!plugin.prototype || !plugin.prototype.constructor) {\r\n        throw \"Sortable: Mounted plugin must be a constructor function, not \".concat({}.toString.call(plugin));\r\n      }\r\n\r\n      if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);\r\n      PluginManager.mount(plugin);\r\n    });\r\n  };\r\n  /**\r\n   * Create sortable instance\r\n   * @param {HTMLElement}  el\r\n   * @param {Object}      [options]\r\n   */\r\n\r\n\r\n  Sortable.create = function (el, options) {\r\n    return new Sortable(el, options);\r\n  }; // Export\r\n\r\n\r\n  Sortable.version = version;\r\n\r\n  var autoScrolls = [],\r\n      scrollEl,\r\n      scrollRootEl,\r\n      scrolling = false,\r\n      lastAutoScrollX,\r\n      lastAutoScrollY,\r\n      touchEvt$1,\r\n      pointerElemChangedInterval;\r\n\r\n  function AutoScrollPlugin() {\r\n    function AutoScroll() {\r\n      this.defaults = {\r\n        scroll: true,\r\n        forceAutoScrollFallback: false,\r\n        scrollSensitivity: 30,\r\n        scrollSpeed: 10,\r\n        bubbleScroll: true\r\n      }; // Bind all private methods\r\n\r\n      for (var fn in this) {\r\n        if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\r\n          this[fn] = this[fn].bind(this);\r\n        }\r\n      }\r\n    }\r\n\r\n    AutoScroll.prototype = {\r\n      dragStarted: function dragStarted(_ref) {\r\n        var originalEvent = _ref.originalEvent;\r\n\r\n        if (this.sortable.nativeDraggable) {\r\n          on(document, 'dragover', this._handleAutoScroll);\r\n        } else {\r\n          if (this.options.supportPointer) {\r\n            on(document, 'pointermove', this._handleFallbackAutoScroll);\r\n          } else if (originalEvent.touches) {\r\n            on(document, 'touchmove', this._handleFallbackAutoScroll);\r\n          } else {\r\n            on(document, 'mousemove', this._handleFallbackAutoScroll);\r\n          }\r\n        }\r\n      },\r\n      dragOverCompleted: function dragOverCompleted(_ref2) {\r\n        var originalEvent = _ref2.originalEvent;\r\n\r\n        // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)\r\n        if (!this.options.dragOverBubble && !originalEvent.rootEl) {\r\n          this._handleAutoScroll(originalEvent);\r\n        }\r\n      },\r\n      drop: function drop() {\r\n        if (this.sortable.nativeDraggable) {\r\n          off(document, 'dragover', this._handleAutoScroll);\r\n        } else {\r\n          off(document, 'pointermove', this._handleFallbackAutoScroll);\r\n          off(document, 'touchmove', this._handleFallbackAutoScroll);\r\n          off(document, 'mousemove', this._handleFallbackAutoScroll);\r\n        }\r\n\r\n        clearPointerElemChangedInterval();\r\n        clearAutoScrolls();\r\n        cancelThrottle();\r\n      },\r\n      nulling: function nulling() {\r\n        touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;\r\n        autoScrolls.length = 0;\r\n      },\r\n      _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {\r\n        this._handleAutoScroll(evt, true);\r\n      },\r\n      _handleAutoScroll: function _handleAutoScroll(evt, fallback) {\r\n        var _this = this;\r\n\r\n        var x = (evt.touches ? evt.touches[0] : evt).clientX,\r\n            y = (evt.touches ? evt.touches[0] : evt).clientY,\r\n            elem = document.elementFromPoint(x, y);\r\n        touchEvt$1 = evt; // IE does not seem to have native autoscroll,\r\n        // Edge's autoscroll seems too conditional,\r\n        // MACOS Safari does not have autoscroll,\r\n        // Firefox and Chrome are good\r\n\r\n        if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {\r\n          autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change\r\n\r\n          var ogElemScroller = getParentAutoScrollElement(elem, true);\r\n\r\n          if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {\r\n            pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour\r\n\r\n            pointerElemChangedInterval = setInterval(function () {\r\n              var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);\r\n\r\n              if (newElem !== ogElemScroller) {\r\n                ogElemScroller = newElem;\r\n                clearAutoScrolls();\r\n              }\r\n\r\n              autoScroll(evt, _this.options, newElem, fallback);\r\n            }, 10);\r\n            lastAutoScrollX = x;\r\n            lastAutoScrollY = y;\r\n          }\r\n        } else {\r\n          // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll\r\n          if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {\r\n            clearAutoScrolls();\r\n            return;\r\n          }\r\n\r\n          autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);\r\n        }\r\n      }\r\n    };\r\n    return _extends(AutoScroll, {\r\n      pluginName: 'scroll',\r\n      initializeByDefault: true\r\n    });\r\n  }\r\n\r\n  function clearAutoScrolls() {\r\n    autoScrolls.forEach(function (autoScroll) {\r\n      clearInterval(autoScroll.pid);\r\n    });\r\n    autoScrolls = [];\r\n  }\r\n\r\n  function clearPointerElemChangedInterval() {\r\n    clearInterval(pointerElemChangedInterval);\r\n  }\r\n\r\n  var autoScroll = throttle(function (evt, options, rootEl, isFallback) {\r\n    // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\r\n    if (!options.scroll) return;\r\n    var x = (evt.touches ? evt.touches[0] : evt).clientX,\r\n        y = (evt.touches ? evt.touches[0] : evt).clientY,\r\n        sens = options.scrollSensitivity,\r\n        speed = options.scrollSpeed,\r\n        winScroller = getWindowScrollingElement();\r\n    var scrollThisInstance = false,\r\n        scrollCustomFn; // New scroll root, set scrollEl\r\n\r\n    if (scrollRootEl !== rootEl) {\r\n      scrollRootEl = rootEl;\r\n      clearAutoScrolls();\r\n      scrollEl = options.scroll;\r\n      scrollCustomFn = options.scrollFn;\r\n\r\n      if (scrollEl === true) {\r\n        scrollEl = getParentAutoScrollElement(rootEl, true);\r\n      }\r\n    }\r\n\r\n    var layersOut = 0;\r\n    var currentParent = scrollEl;\r\n\r\n    do {\r\n      var el = currentParent,\r\n          rect = getRect(el),\r\n          top = rect.top,\r\n          bottom = rect.bottom,\r\n          left = rect.left,\r\n          right = rect.right,\r\n          width = rect.width,\r\n          height = rect.height,\r\n          canScrollX = void 0,\r\n          canScrollY = void 0,\r\n          scrollWidth = el.scrollWidth,\r\n          scrollHeight = el.scrollHeight,\r\n          elCSS = css(el),\r\n          scrollPosX = el.scrollLeft,\r\n          scrollPosY = el.scrollTop;\r\n\r\n      if (el === winScroller) {\r\n        canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');\r\n        canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');\r\n      } else {\r\n        canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');\r\n        canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');\r\n      }\r\n\r\n      var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);\r\n      var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);\r\n\r\n      if (!autoScrolls[layersOut]) {\r\n        for (var i = 0; i <= layersOut; i++) {\r\n          if (!autoScrolls[i]) {\r\n            autoScrolls[i] = {};\r\n          }\r\n        }\r\n      }\r\n\r\n      if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {\r\n        autoScrolls[layersOut].el = el;\r\n        autoScrolls[layersOut].vx = vx;\r\n        autoScrolls[layersOut].vy = vy;\r\n        clearInterval(autoScrolls[layersOut].pid);\r\n\r\n        if (vx != 0 || vy != 0) {\r\n          scrollThisInstance = true;\r\n          /* jshint loopfunc:true */\r\n\r\n          autoScrolls[layersOut].pid = setInterval(function () {\r\n            // emulate drag over during autoscroll (fallback), emulating native DnD behaviour\r\n            if (isFallback && this.layer === 0) {\r\n              Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely\r\n\r\n            }\r\n\r\n            var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;\r\n            var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;\r\n\r\n            if (typeof scrollCustomFn === 'function') {\r\n              if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {\r\n                return;\r\n              }\r\n            }\r\n\r\n            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);\r\n          }.bind({\r\n            layer: layersOut\r\n          }), 24);\r\n        }\r\n      }\r\n\r\n      layersOut++;\r\n    } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));\r\n\r\n    scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not\r\n  }, 30);\r\n\r\n  var drop = function drop(_ref) {\r\n    var originalEvent = _ref.originalEvent,\r\n        putSortable = _ref.putSortable,\r\n        dragEl = _ref.dragEl,\r\n        activeSortable = _ref.activeSortable,\r\n        dispatchSortableEvent = _ref.dispatchSortableEvent,\r\n        hideGhostForTarget = _ref.hideGhostForTarget,\r\n        unhideGhostForTarget = _ref.unhideGhostForTarget;\r\n    if (!originalEvent) return;\r\n    var toSortable = putSortable || activeSortable;\r\n    hideGhostForTarget();\r\n    var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;\r\n    var target = document.elementFromPoint(touch.clientX, touch.clientY);\r\n    unhideGhostForTarget();\r\n\r\n    if (toSortable && !toSortable.el.contains(target)) {\r\n      dispatchSortableEvent('spill');\r\n      this.onSpill({\r\n        dragEl: dragEl,\r\n        putSortable: putSortable\r\n      });\r\n    }\r\n  };\r\n\r\n  function Revert() {}\r\n\r\n  Revert.prototype = {\r\n    startIndex: null,\r\n    dragStart: function dragStart(_ref2) {\r\n      var oldDraggableIndex = _ref2.oldDraggableIndex;\r\n      this.startIndex = oldDraggableIndex;\r\n    },\r\n    onSpill: function onSpill(_ref3) {\r\n      var dragEl = _ref3.dragEl,\r\n          putSortable = _ref3.putSortable;\r\n      this.sortable.captureAnimationState();\r\n\r\n      if (putSortable) {\r\n        putSortable.captureAnimationState();\r\n      }\r\n\r\n      var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);\r\n\r\n      if (nextSibling) {\r\n        this.sortable.el.insertBefore(dragEl, nextSibling);\r\n      } else {\r\n        this.sortable.el.appendChild(dragEl);\r\n      }\r\n\r\n      this.sortable.animateAll();\r\n\r\n      if (putSortable) {\r\n        putSortable.animateAll();\r\n      }\r\n    },\r\n    drop: drop\r\n  };\r\n\r\n  _extends(Revert, {\r\n    pluginName: 'revertOnSpill'\r\n  });\r\n\r\n  function Remove() {}\r\n\r\n  Remove.prototype = {\r\n    onSpill: function onSpill(_ref4) {\r\n      var dragEl = _ref4.dragEl,\r\n          putSortable = _ref4.putSortable;\r\n      var parentSortable = putSortable || this.sortable;\r\n      parentSortable.captureAnimationState();\r\n      dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);\r\n      parentSortable.animateAll();\r\n    },\r\n    drop: drop\r\n  };\r\n\r\n  _extends(Remove, {\r\n    pluginName: 'removeOnSpill'\r\n  });\r\n\r\n  var lastSwapEl;\r\n\r\n  function SwapPlugin() {\r\n    function Swap() {\r\n      this.defaults = {\r\n        swapClass: 'sortable-swap-highlight'\r\n      };\r\n    }\r\n\r\n    Swap.prototype = {\r\n      dragStart: function dragStart(_ref) {\r\n        var dragEl = _ref.dragEl;\r\n        lastSwapEl = dragEl;\r\n      },\r\n      dragOverValid: function dragOverValid(_ref2) {\r\n        var completed = _ref2.completed,\r\n            target = _ref2.target,\r\n            onMove = _ref2.onMove,\r\n            activeSortable = _ref2.activeSortable,\r\n            changed = _ref2.changed,\r\n            cancel = _ref2.cancel;\r\n        if (!activeSortable.options.swap) return;\r\n        var el = this.sortable.el,\r\n            options = this.options;\r\n\r\n        if (target && target !== el) {\r\n          var prevSwapEl = lastSwapEl;\r\n\r\n          if (onMove(target) !== false) {\r\n            toggleClass(target, options.swapClass, true);\r\n            lastSwapEl = target;\r\n          } else {\r\n            lastSwapEl = null;\r\n          }\r\n\r\n          if (prevSwapEl && prevSwapEl !== lastSwapEl) {\r\n            toggleClass(prevSwapEl, options.swapClass, false);\r\n          }\r\n        }\r\n\r\n        changed();\r\n        completed(true);\r\n        cancel();\r\n      },\r\n      drop: function drop(_ref3) {\r\n        var activeSortable = _ref3.activeSortable,\r\n            putSortable = _ref3.putSortable,\r\n            dragEl = _ref3.dragEl;\r\n        var toSortable = putSortable || this.sortable;\r\n        var options = this.options;\r\n        lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);\r\n\r\n        if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {\r\n          if (dragEl !== lastSwapEl) {\r\n            toSortable.captureAnimationState();\r\n            if (toSortable !== activeSortable) activeSortable.captureAnimationState();\r\n            swapNodes(dragEl, lastSwapEl);\r\n            toSortable.animateAll();\r\n            if (toSortable !== activeSortable) activeSortable.animateAll();\r\n          }\r\n        }\r\n      },\r\n      nulling: function nulling() {\r\n        lastSwapEl = null;\r\n      }\r\n    };\r\n    return _extends(Swap, {\r\n      pluginName: 'swap',\r\n      eventProperties: function eventProperties() {\r\n        return {\r\n          swapItem: lastSwapEl\r\n        };\r\n      }\r\n    });\r\n  }\r\n\r\n  function swapNodes(n1, n2) {\r\n    var p1 = n1.parentNode,\r\n        p2 = n2.parentNode,\r\n        i1,\r\n        i2;\r\n    if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;\r\n    i1 = index(n1);\r\n    i2 = index(n2);\r\n\r\n    if (p1.isEqualNode(p2) && i1 < i2) {\r\n      i2++;\r\n    }\r\n\r\n    p1.insertBefore(n2, p1.children[i1]);\r\n    p2.insertBefore(n1, p2.children[i2]);\r\n  }\r\n\r\n  var multiDragElements = [],\r\n      multiDragClones = [],\r\n      lastMultiDragSelect,\r\n      // for selection with modifier key down (SHIFT)\r\n  multiDragSortable,\r\n      initialFolding = false,\r\n      // Initial multi-drag fold when drag started\r\n  folding = false,\r\n      // Folding any other time\r\n  dragStarted = false,\r\n      dragEl$1,\r\n      clonesFromRect,\r\n      clonesHidden;\r\n\r\n  function MultiDragPlugin() {\r\n    function MultiDrag(sortable) {\r\n      // Bind all private methods\r\n      for (var fn in this) {\r\n        if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\r\n          this[fn] = this[fn].bind(this);\r\n        }\r\n      }\r\n\r\n      if (!sortable.options.avoidImplicitDeselect) {\r\n        if (sortable.options.supportPointer) {\r\n          on(document, 'pointerup', this._deselectMultiDrag);\r\n        } else {\r\n          on(document, 'mouseup', this._deselectMultiDrag);\r\n          on(document, 'touchend', this._deselectMultiDrag);\r\n        }\r\n      }\r\n\r\n      on(document, 'keydown', this._checkKeyDown);\r\n      on(document, 'keyup', this._checkKeyUp);\r\n      this.defaults = {\r\n        selectedClass: 'sortable-selected',\r\n        multiDragKey: null,\r\n        avoidImplicitDeselect: false,\r\n        setData: function setData(dataTransfer, dragEl) {\r\n          var data = '';\r\n\r\n          if (multiDragElements.length && multiDragSortable === sortable) {\r\n            multiDragElements.forEach(function (multiDragElement, i) {\r\n              data += (!i ? '' : ', ') + multiDragElement.textContent;\r\n            });\r\n          } else {\r\n            data = dragEl.textContent;\r\n          }\r\n\r\n          dataTransfer.setData('Text', data);\r\n        }\r\n      };\r\n    }\r\n\r\n    MultiDrag.prototype = {\r\n      multiDragKeyDown: false,\r\n      isMultiDrag: false,\r\n      delayStartGlobal: function delayStartGlobal(_ref) {\r\n        var dragged = _ref.dragEl;\r\n        dragEl$1 = dragged;\r\n      },\r\n      delayEnded: function delayEnded() {\r\n        this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);\r\n      },\r\n      setupClone: function setupClone(_ref2) {\r\n        var sortable = _ref2.sortable,\r\n            cancel = _ref2.cancel;\r\n        if (!this.isMultiDrag) return;\r\n\r\n        for (var i = 0; i < multiDragElements.length; i++) {\r\n          multiDragClones.push(clone(multiDragElements[i]));\r\n          multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;\r\n          multiDragClones[i].draggable = false;\r\n          multiDragClones[i].style['will-change'] = '';\r\n          toggleClass(multiDragClones[i], this.options.selectedClass, false);\r\n          multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);\r\n        }\r\n\r\n        sortable._hideClone();\r\n\r\n        cancel();\r\n      },\r\n      clone: function clone(_ref3) {\r\n        var sortable = _ref3.sortable,\r\n            rootEl = _ref3.rootEl,\r\n            dispatchSortableEvent = _ref3.dispatchSortableEvent,\r\n            cancel = _ref3.cancel;\r\n        if (!this.isMultiDrag) return;\r\n\r\n        if (!this.options.removeCloneOnHide) {\r\n          if (multiDragElements.length && multiDragSortable === sortable) {\r\n            insertMultiDragClones(true, rootEl);\r\n            dispatchSortableEvent('clone');\r\n            cancel();\r\n          }\r\n        }\r\n      },\r\n      showClone: function showClone(_ref4) {\r\n        var cloneNowShown = _ref4.cloneNowShown,\r\n            rootEl = _ref4.rootEl,\r\n            cancel = _ref4.cancel;\r\n        if (!this.isMultiDrag) return;\r\n        insertMultiDragClones(false, rootEl);\r\n        multiDragClones.forEach(function (clone) {\r\n          css(clone, 'display', '');\r\n        });\r\n        cloneNowShown();\r\n        clonesHidden = false;\r\n        cancel();\r\n      },\r\n      hideClone: function hideClone(_ref5) {\r\n        var _this = this;\r\n\r\n        var sortable = _ref5.sortable,\r\n            cloneNowHidden = _ref5.cloneNowHidden,\r\n            cancel = _ref5.cancel;\r\n        if (!this.isMultiDrag) return;\r\n        multiDragClones.forEach(function (clone) {\r\n          css(clone, 'display', 'none');\r\n\r\n          if (_this.options.removeCloneOnHide && clone.parentNode) {\r\n            clone.parentNode.removeChild(clone);\r\n          }\r\n        });\r\n        cloneNowHidden();\r\n        clonesHidden = true;\r\n        cancel();\r\n      },\r\n      dragStartGlobal: function dragStartGlobal(_ref6) {\r\n        var sortable = _ref6.sortable;\r\n\r\n        if (!this.isMultiDrag && multiDragSortable) {\r\n          multiDragSortable.multiDrag._deselectMultiDrag();\r\n        }\r\n\r\n        multiDragElements.forEach(function (multiDragElement) {\r\n          multiDragElement.sortableIndex = index(multiDragElement);\r\n        }); // Sort multi-drag elements\r\n\r\n        multiDragElements = multiDragElements.sort(function (a, b) {\r\n          return a.sortableIndex - b.sortableIndex;\r\n        });\r\n        dragStarted = true;\r\n      },\r\n      dragStarted: function dragStarted(_ref7) {\r\n        var _this2 = this;\r\n\r\n        var sortable = _ref7.sortable;\r\n        if (!this.isMultiDrag) return;\r\n\r\n        if (this.options.sort) {\r\n          // Capture rects,\r\n          // hide multi drag elements (by positioning them absolute),\r\n          // set multi drag elements rects to dragRect,\r\n          // show multi drag elements,\r\n          // animate to rects,\r\n          // unset rects & remove from DOM\r\n          sortable.captureAnimationState();\r\n\r\n          if (this.options.animation) {\r\n            multiDragElements.forEach(function (multiDragElement) {\r\n              if (multiDragElement === dragEl$1) return;\r\n              css(multiDragElement, 'position', 'absolute');\r\n            });\r\n            var dragRect = getRect(dragEl$1, false, true, true);\r\n            multiDragElements.forEach(function (multiDragElement) {\r\n              if (multiDragElement === dragEl$1) return;\r\n              setRect(multiDragElement, dragRect);\r\n            });\r\n            folding = true;\r\n            initialFolding = true;\r\n          }\r\n        }\r\n\r\n        sortable.animateAll(function () {\r\n          folding = false;\r\n          initialFolding = false;\r\n\r\n          if (_this2.options.animation) {\r\n            multiDragElements.forEach(function (multiDragElement) {\r\n              unsetRect(multiDragElement);\r\n            });\r\n          } // Remove all auxiliary multidrag items from el, if sorting enabled\r\n\r\n\r\n          if (_this2.options.sort) {\r\n            removeMultiDragElements();\r\n          }\r\n        });\r\n      },\r\n      dragOver: function dragOver(_ref8) {\r\n        var target = _ref8.target,\r\n            completed = _ref8.completed,\r\n            cancel = _ref8.cancel;\r\n\r\n        if (folding && ~multiDragElements.indexOf(target)) {\r\n          completed(false);\r\n          cancel();\r\n        }\r\n      },\r\n      revert: function revert(_ref9) {\r\n        var fromSortable = _ref9.fromSortable,\r\n            rootEl = _ref9.rootEl,\r\n            sortable = _ref9.sortable,\r\n            dragRect = _ref9.dragRect;\r\n\r\n        if (multiDragElements.length > 1) {\r\n          // Setup unfold animation\r\n          multiDragElements.forEach(function (multiDragElement) {\r\n            sortable.addAnimationState({\r\n              target: multiDragElement,\r\n              rect: folding ? getRect(multiDragElement) : dragRect\r\n            });\r\n            unsetRect(multiDragElement);\r\n            multiDragElement.fromRect = dragRect;\r\n            fromSortable.removeAnimationState(multiDragElement);\r\n          });\r\n          folding = false;\r\n          insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);\r\n        }\r\n      },\r\n      dragOverCompleted: function dragOverCompleted(_ref10) {\r\n        var sortable = _ref10.sortable,\r\n            isOwner = _ref10.isOwner,\r\n            insertion = _ref10.insertion,\r\n            activeSortable = _ref10.activeSortable,\r\n            parentEl = _ref10.parentEl,\r\n            putSortable = _ref10.putSortable;\r\n        var options = this.options;\r\n\r\n        if (insertion) {\r\n          // Clones must be hidden before folding animation to capture dragRectAbsolute properly\r\n          if (isOwner) {\r\n            activeSortable._hideClone();\r\n          }\r\n\r\n          initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location\r\n\r\n          if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {\r\n            // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible\r\n            var dragRectAbsolute = getRect(dragEl$1, false, true, true);\r\n            multiDragElements.forEach(function (multiDragElement) {\r\n              if (multiDragElement === dragEl$1) return;\r\n              setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted\r\n              // while folding, and so that we can capture them again because old sortable will no longer be fromSortable\r\n\r\n              parentEl.appendChild(multiDragElement);\r\n            });\r\n            folding = true;\r\n          } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out\r\n\r\n\r\n          if (!isOwner) {\r\n            // Only remove if not folding (folding will remove them anyways)\r\n            if (!folding) {\r\n              removeMultiDragElements();\r\n            }\r\n\r\n            if (multiDragElements.length > 1) {\r\n              var clonesHiddenBefore = clonesHidden;\r\n\r\n              activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden\r\n\r\n\r\n              if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {\r\n                multiDragClones.forEach(function (clone) {\r\n                  activeSortable.addAnimationState({\r\n                    target: clone,\r\n                    rect: clonesFromRect\r\n                  });\r\n                  clone.fromRect = clonesFromRect;\r\n                  clone.thisAnimationDuration = null;\r\n                });\r\n              }\r\n            } else {\r\n              activeSortable._showClone(sortable);\r\n            }\r\n          }\r\n        }\r\n      },\r\n      dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {\r\n        var dragRect = _ref11.dragRect,\r\n            isOwner = _ref11.isOwner,\r\n            activeSortable = _ref11.activeSortable;\r\n        multiDragElements.forEach(function (multiDragElement) {\r\n          multiDragElement.thisAnimationDuration = null;\r\n        });\r\n\r\n        if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {\r\n          clonesFromRect = _extends({}, dragRect);\r\n          var dragMatrix = matrix(dragEl$1, true);\r\n          clonesFromRect.top -= dragMatrix.f;\r\n          clonesFromRect.left -= dragMatrix.e;\r\n        }\r\n      },\r\n      dragOverAnimationComplete: function dragOverAnimationComplete() {\r\n        if (folding) {\r\n          folding = false;\r\n          removeMultiDragElements();\r\n        }\r\n      },\r\n      drop: function drop(_ref12) {\r\n        var evt = _ref12.originalEvent,\r\n            rootEl = _ref12.rootEl,\r\n            parentEl = _ref12.parentEl,\r\n            sortable = _ref12.sortable,\r\n            dispatchSortableEvent = _ref12.dispatchSortableEvent,\r\n            oldIndex = _ref12.oldIndex,\r\n            putSortable = _ref12.putSortable;\r\n        var toSortable = putSortable || this.sortable;\r\n        if (!evt) return;\r\n        var options = this.options,\r\n            children = parentEl.children; // Multi-drag selection\r\n\r\n        if (!dragStarted) {\r\n          if (options.multiDragKey && !this.multiDragKeyDown) {\r\n            this._deselectMultiDrag();\r\n          }\r\n\r\n          toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));\r\n\r\n          if (!~multiDragElements.indexOf(dragEl$1)) {\r\n            multiDragElements.push(dragEl$1);\r\n            dispatchEvent({\r\n              sortable: sortable,\r\n              rootEl: rootEl,\r\n              name: 'select',\r\n              targetEl: dragEl$1,\r\n              originalEvent: evt\r\n            }); // Modifier activated, select from last to dragEl\r\n\r\n            if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {\r\n              var lastIndex = index(lastMultiDragSelect),\r\n                  currentIndex = index(dragEl$1);\r\n\r\n              if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {\r\n                // Must include lastMultiDragSelect (select it), in case modified selection from no selection\r\n                // (but previous selection existed)\r\n                var n, i;\r\n\r\n                if (currentIndex > lastIndex) {\r\n                  i = lastIndex;\r\n                  n = currentIndex;\r\n                } else {\r\n                  i = currentIndex;\r\n                  n = lastIndex + 1;\r\n                }\r\n\r\n                for (; i < n; i++) {\r\n                  if (~multiDragElements.indexOf(children[i])) continue;\r\n                  toggleClass(children[i], options.selectedClass, true);\r\n                  multiDragElements.push(children[i]);\r\n                  dispatchEvent({\r\n                    sortable: sortable,\r\n                    rootEl: rootEl,\r\n                    name: 'select',\r\n                    targetEl: children[i],\r\n                    originalEvent: evt\r\n                  });\r\n                }\r\n              }\r\n            } else {\r\n              lastMultiDragSelect = dragEl$1;\r\n            }\r\n\r\n            multiDragSortable = toSortable;\r\n          } else {\r\n            multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);\r\n            lastMultiDragSelect = null;\r\n            dispatchEvent({\r\n              sortable: sortable,\r\n              rootEl: rootEl,\r\n              name: 'deselect',\r\n              targetEl: dragEl$1,\r\n              originalEvent: evt\r\n            });\r\n          }\r\n        } // Multi-drag drop\r\n\r\n\r\n        if (dragStarted && this.isMultiDrag) {\r\n          folding = false; // Do not \"unfold\" after around dragEl if reverted\r\n\r\n          if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {\r\n            var dragRect = getRect(dragEl$1),\r\n                multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');\r\n            if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;\r\n            toSortable.captureAnimationState();\r\n\r\n            if (!initialFolding) {\r\n              if (options.animation) {\r\n                dragEl$1.fromRect = dragRect;\r\n                multiDragElements.forEach(function (multiDragElement) {\r\n                  multiDragElement.thisAnimationDuration = null;\r\n\r\n                  if (multiDragElement !== dragEl$1) {\r\n                    var rect = folding ? getRect(multiDragElement) : dragRect;\r\n                    multiDragElement.fromRect = rect; // Prepare unfold animation\r\n\r\n                    toSortable.addAnimationState({\r\n                      target: multiDragElement,\r\n                      rect: rect\r\n                    });\r\n                  }\r\n                });\r\n              } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert\r\n              // properly they must all be removed\r\n\r\n\r\n              removeMultiDragElements();\r\n              multiDragElements.forEach(function (multiDragElement) {\r\n                if (children[multiDragIndex]) {\r\n                  parentEl.insertBefore(multiDragElement, children[multiDragIndex]);\r\n                } else {\r\n                  parentEl.appendChild(multiDragElement);\r\n                }\r\n\r\n                multiDragIndex++;\r\n              }); // If initial folding is done, the elements may have changed position because they are now\r\n              // unfolding around dragEl, even though dragEl may not have his index changed, so update event\r\n              // must be fired here as Sortable will not.\r\n\r\n              if (oldIndex === index(dragEl$1)) {\r\n                var update = false;\r\n                multiDragElements.forEach(function (multiDragElement) {\r\n                  if (multiDragElement.sortableIndex !== index(multiDragElement)) {\r\n                    update = true;\r\n                    return;\r\n                  }\r\n                });\r\n\r\n                if (update) {\r\n                  dispatchSortableEvent('update');\r\n                }\r\n              }\r\n            } // Must be done after capturing individual rects (scroll bar)\r\n\r\n\r\n            multiDragElements.forEach(function (multiDragElement) {\r\n              unsetRect(multiDragElement);\r\n            });\r\n            toSortable.animateAll();\r\n          }\r\n\r\n          multiDragSortable = toSortable;\r\n        } // Remove clones if necessary\r\n\r\n\r\n        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\r\n          multiDragClones.forEach(function (clone) {\r\n            clone.parentNode && clone.parentNode.removeChild(clone);\r\n          });\r\n        }\r\n      },\r\n      nullingGlobal: function nullingGlobal() {\r\n        this.isMultiDrag = dragStarted = false;\r\n        multiDragClones.length = 0;\r\n      },\r\n      destroyGlobal: function destroyGlobal() {\r\n        this._deselectMultiDrag();\r\n\r\n        off(document, 'pointerup', this._deselectMultiDrag);\r\n        off(document, 'mouseup', this._deselectMultiDrag);\r\n        off(document, 'touchend', this._deselectMultiDrag);\r\n        off(document, 'keydown', this._checkKeyDown);\r\n        off(document, 'keyup', this._checkKeyUp);\r\n      },\r\n      _deselectMultiDrag: function _deselectMultiDrag(evt) {\r\n        if (typeof dragStarted !== \"undefined\" && dragStarted) return; // Only deselect if selection is in this sortable\r\n\r\n        if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable\r\n\r\n        if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click\r\n\r\n        if (evt && evt.button !== 0) return;\r\n\r\n        while (multiDragElements.length) {\r\n          var el = multiDragElements[0];\r\n          toggleClass(el, this.options.selectedClass, false);\r\n          multiDragElements.shift();\r\n          dispatchEvent({\r\n            sortable: this.sortable,\r\n            rootEl: this.sortable.el,\r\n            name: 'deselect',\r\n            targetEl: el,\r\n            originalEvent: evt\r\n          });\r\n        }\r\n      },\r\n      _checkKeyDown: function _checkKeyDown(evt) {\r\n        if (evt.key === this.options.multiDragKey) {\r\n          this.multiDragKeyDown = true;\r\n        }\r\n      },\r\n      _checkKeyUp: function _checkKeyUp(evt) {\r\n        if (evt.key === this.options.multiDragKey) {\r\n          this.multiDragKeyDown = false;\r\n        }\r\n      }\r\n    };\r\n    return _extends(MultiDrag, {\r\n      // Static methods & properties\r\n      pluginName: 'multiDrag',\r\n      utils: {\r\n        /**\r\n         * Selects the provided multi-drag item\r\n         * @param  {HTMLElement} el    The element to be selected\r\n         */\r\n        select: function select(el) {\r\n          var sortable = el.parentNode[expando];\r\n          if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;\r\n\r\n          if (multiDragSortable && multiDragSortable !== sortable) {\r\n            multiDragSortable.multiDrag._deselectMultiDrag();\r\n\r\n            multiDragSortable = sortable;\r\n          }\r\n\r\n          toggleClass(el, sortable.options.selectedClass, true);\r\n          multiDragElements.push(el);\r\n        },\r\n\r\n        /**\r\n         * Deselects the provided multi-drag item\r\n         * @param  {HTMLElement} el    The element to be deselected\r\n         */\r\n        deselect: function deselect(el) {\r\n          var sortable = el.parentNode[expando],\r\n              index = multiDragElements.indexOf(el);\r\n          if (!sortable || !sortable.options.multiDrag || !~index) return;\r\n          toggleClass(el, sortable.options.selectedClass, false);\r\n          multiDragElements.splice(index, 1);\r\n        }\r\n      },\r\n      eventProperties: function eventProperties() {\r\n        var _this3 = this;\r\n\r\n        var oldIndicies = [],\r\n            newIndicies = [];\r\n        multiDragElements.forEach(function (multiDragElement) {\r\n          oldIndicies.push({\r\n            multiDragElement: multiDragElement,\r\n            index: multiDragElement.sortableIndex\r\n          }); // multiDragElements will already be sorted if folding\r\n\r\n          var newIndex;\r\n\r\n          if (folding && multiDragElement !== dragEl$1) {\r\n            newIndex = -1;\r\n          } else if (folding) {\r\n            newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');\r\n          } else {\r\n            newIndex = index(multiDragElement);\r\n          }\r\n\r\n          newIndicies.push({\r\n            multiDragElement: multiDragElement,\r\n            index: newIndex\r\n          });\r\n        });\r\n        return {\r\n          items: _toConsumableArray(multiDragElements),\r\n          clones: [].concat(multiDragClones),\r\n          oldIndicies: oldIndicies,\r\n          newIndicies: newIndicies\r\n        };\r\n      },\r\n      optionListeners: {\r\n        multiDragKey: function multiDragKey(key) {\r\n          key = key.toLowerCase();\r\n\r\n          if (key === 'ctrl') {\r\n            key = 'Control';\r\n          } else if (key.length > 1) {\r\n            key = key.charAt(0).toUpperCase() + key.substr(1);\r\n          }\r\n\r\n          return key;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  function insertMultiDragElements(clonesInserted, rootEl) {\r\n    multiDragElements.forEach(function (multiDragElement, i) {\r\n      var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];\r\n\r\n      if (target) {\r\n        rootEl.insertBefore(multiDragElement, target);\r\n      } else {\r\n        rootEl.appendChild(multiDragElement);\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * Insert multi-drag clones\r\n   * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted\r\n   * @param  {HTMLElement} rootEl\r\n   */\r\n\r\n\r\n  function insertMultiDragClones(elementsInserted, rootEl) {\r\n    multiDragClones.forEach(function (clone, i) {\r\n      var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];\r\n\r\n      if (target) {\r\n        rootEl.insertBefore(clone, target);\r\n      } else {\r\n        rootEl.appendChild(clone);\r\n      }\r\n    });\r\n  }\r\n\r\n  function removeMultiDragElements() {\r\n    multiDragElements.forEach(function (multiDragElement) {\r\n      if (multiDragElement === dragEl$1) return;\r\n      multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);\r\n    });\r\n  }\r\n\r\n  Sortable.mount(new AutoScrollPlugin());\r\n  Sortable.mount(Remove, Revert);\r\n\r\n  Sortable.mount(new SwapPlugin());\r\n  Sortable.mount(new MultiDragPlugin());\r\n\r\n  return Sortable;\r\n\r\n})));\r\n\n\n//# sourceURL=webpack://setup-webpack/./src/modules/Sortable.js?");

/***/ }),

/***/ "./src/modules/Start.js":
/*!******************************!*\
  !*** ./src/modules/Start.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ start)\n/* harmony export */ });\n/* harmony import */ var _themeController_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./themeController.js */ \"./src/modules/themeController.js\");\n/* harmony import */ var _todoController_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./todoController.js */ \"./src/modules/todoController.js\");\n/* harmony import */ var _Sortable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Sortable.js */ \"./src/modules/Sortable.js\");\n/* harmony import */ var _Sortable_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Sortable_js__WEBPACK_IMPORTED_MODULE_2__);\n// import project modules\r\n\r\n\r\n\r\n\r\nfunction start() {\r\n  (0,_themeController_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\r\n  const controller = new _todoController_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\r\n  controller.run();\r\n  new (_Sortable_js__WEBPACK_IMPORTED_MODULE_2___default())(document.querySelector('.todo-list'), {\r\n    animation: 300,\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack://setup-webpack/./src/modules/Start.js?");

/***/ }),

/***/ "./src/modules/Todo.js":
/*!*****************************!*\
  !*** ./src/modules/Todo.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Todo)\n/* harmony export */ });\nclass Todo {\r\n  //constructor function to assign the todo properties\r\n  constructor(description, completed = false) {\r\n    this.description = description;\r\n    this.index = this.getIndex() + 1;\r\n    this.completed = completed;\r\n  }\r\n\r\n  // function to get the array length from local storage\r\n  getIndex() {\r\n    let items = JSON.parse(localStorage.getItem('todos'));\r\n    return items ? items.length : 0;\r\n  }\r\n\r\n  // function to add new todo to the local storage\r\n  addTodo() {\r\n    let dataStored = [];\r\n    let todos = [];\r\n    if (localStorage.getItem('todos')) {\r\n      dataStored = localStorage.getItem('todos');\r\n      todos = JSON.parse(dataStored);\r\n    }\r\n    todos.push(this);\r\n    this.updateLocalStorage(todos);\r\n  }\r\n\r\n  // function to get all the todo items stored in the local storage\r\n  getTodo(state = 'all') {\r\n    let todos = 0;\r\n    let dataStored = localStorage.getItem('todos');\r\n    if (dataStored && state === 'all') {\r\n      todos = JSON.parse(dataStored);\r\n    } else if (dataStored) {\r\n      let data = JSON.parse(dataStored);\r\n      todos = data.filter(this.getPartOfData(state));\r\n    }\r\n    return todos;\r\n  }\r\n\r\n  getPartOfData(part) {\r\n    if (part === 'active') {\r\n      return function (element) {\r\n        if (element.completed === false) {\r\n          return element;\r\n        }\r\n      };\r\n    } else {\r\n      return function (element) {\r\n        if (element.completed === true) {\r\n          return element;\r\n        }\r\n      };\r\n    }\r\n  }\r\n\r\n  // function to delete an specific item from local storage based on it's ID\r\n  deleteTodo(index) {\r\n    const toDos = this.getTodo();\r\n    let data = toDos.filter(this.cleanData(index));\r\n    let update = data.map(this.updateID(index));\r\n    this.updateLocalStorage(update);\r\n  }\r\n\r\n  // function to filter existing data from the one intended to be deleted\r\n  cleanData(index) {\r\n    return function (element) {\r\n      return element.index != index;\r\n    };\r\n  }\r\n\r\n  //function to update a todo task\r\n  updateTodo(index, value) {\r\n    const toDos = this.getTodo();\r\n    let update = toDos.map(this.updateData(index, value));\r\n    this.updateLocalStorage(update);\r\n  }\r\n\r\n  // function to filter existing data from the one intended to be deleted\r\n  updateData(index, value) {\r\n    return function (element) {\r\n      if (element.index == index) {\r\n        element.description = value;\r\n      }\r\n      return element;\r\n    };\r\n  }\r\n\r\n  // function to update the rest of remaining elements ID after deleting one\r\n  updateID(index) {\r\n    return function (element) {\r\n      if (element.index > index) {\r\n        element.index -= 1;\r\n      }\r\n      return element;\r\n    };\r\n  }\r\n\r\n  // function to mark a todo as a complete\r\n  markComplete(index, completed) {\r\n    const toDos = this.getTodo();\r\n    let update = toDos.map(this.updateStatus(index, completed));\r\n    this.updateLocalStorage(update);\r\n  }\r\n\r\n  updateStatus(index, operation) {\r\n    return function (element) {\r\n      if (element.index == index) {\r\n        element.completed = operation;\r\n      }\r\n      return element;\r\n    };\r\n  }\r\n\r\n  // function to update local storage with new data\r\n  updateLocalStorage(data) {\r\n    localStorage.setItem('todos', JSON.stringify(data));\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://setup-webpack/./src/modules/Todo.js?");

/***/ }),

/***/ "./src/modules/themeController.js":
/*!****************************************!*\
  !*** ./src/modules/themeController.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ themeController)\n/* harmony export */ });\n/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../styles.css */ \"./src/styles.css\");\n// project style file\r\n\r\n\r\nfunction themeController() {\r\n  // changing todo input element's placeholder value on focus\r\n  const todoInput = document.querySelector('.todo-input');\r\n  todoInput.addEventListener('focus', (e) => {\r\n    e.target.placeholder = 'Currently typing...';\r\n  });\r\n\r\n  // changing todo input element's placeholder value on blur\r\n  todoInput.addEventListener('blur', (e) => {\r\n    e.target.placeholder = 'Create a new todo...';\r\n  });\r\n\r\n  // get user prefer color theme through the system preferred theme or through local storage\r\n  function getCurrentTheme() {\r\n    let theme = window.matchMedia('(prefers-color-scheme: dark)').matches\r\n      ? 'dark'\r\n      : 'light';\r\n    localStorage.getItem('todo.theme')\r\n      ? (theme = localStorage.getItem('todo.theme'))\r\n      : null;\r\n    return theme;\r\n  }\r\n\r\n  // select theme changer button\r\n  const themeChanger = document.querySelector('.themeChanger');\r\n\r\n  // load the current active theme and change the UI based on that\r\n  function loadTheme(theme) {\r\n    const root = document.querySelector(':root');\r\n    if (theme === 'light') {\r\n      themeChanger.src = './images/icon-moon.png';\r\n    } else {\r\n      themeChanger.src = './images/icon-sun.png';\r\n    }\r\n    root.setAttribute('color-scheme', `${theme}`);\r\n  }\r\n\r\n  // add an event listener to change between light and dark mode base on the user click\r\n  themeChanger.addEventListener('click', (e) => {\r\n    const element = e.target;\r\n    let theme = getCurrentTheme();\r\n    if (theme === 'dark') {\r\n      element.src = './images/icon-sun.png';\r\n      theme = 'light';\r\n      localStorage.setItem('todo.theme', `${theme}`);\r\n    } else {\r\n      element.src = './images/icon-moon.png';\r\n      theme = 'dark';\r\n      localStorage.setItem('todo.theme', `${theme}`);\r\n    }\r\n\r\n    loadTheme(theme);\r\n  });\r\n\r\n  // add an event lister to the window load to active the user's active theme\r\n  window.addEventListener('DOMContentLoaded', () => {\r\n    loadTheme(getCurrentTheme());\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack://setup-webpack/./src/modules/themeController.js?");

/***/ }),

/***/ "./src/modules/todoController.js":
/*!***************************************!*\
  !*** ./src/modules/todoController.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TodoController)\n/* harmony export */ });\n/* harmony import */ var _Todo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Todo.js */ \"./src/modules/Todo.js\");\n\r\n\r\nclass TodoController {\r\n  constructor() {\r\n    const todo = new _Todo_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    const data = todo.getTodo('active');\r\n    this.counter = data.length;\r\n    this.counterContainer = document.querySelector('.counter');\r\n  }\r\n\r\n  activeCount() {\r\n    const todo = new _Todo_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    const data = todo.getTodo('active');\r\n    return data.length;\r\n  }\r\n\r\n  run() {\r\n    this.formListener();\r\n    this.displayTodo();\r\n    this.getPartOfData();\r\n    this.deleteCompleted();\r\n  }\r\n\r\n  // function to listen to form submission\r\n  formListener() {\r\n    const form = document.querySelector('.form');\r\n    form.addEventListener('submit', this.createTodo);\r\n  }\r\n\r\n  // function to create new todo object\r\n  createTodo() {\r\n    const dataContainer = document.querySelector('.todo-list');\r\n    const input = document.querySelector('.todo-input');\r\n    const todo = new _Todo_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](input.value);\r\n    todo.addTodo();\r\n    input.value = null;\r\n    if (todo.getIndex() <= 1) {\r\n      dataContainer.innerHTML = '';\r\n      this.counter = 0;\r\n    }\r\n    dataContainer.innerHTML += `\r\n        <li class=\"todo-item px-4\" id=\"${todo.index}\" >\r\n            <span class=\"check change-state\"></span>\r\n            <input class=\"mark-complete\" type=\"checkbox\" name=\"todo\" value=\"${todo.description}\">\r\n            <p title=\"Double click to edit\" class=\"task\">${todo.description}</p>\r\n            <img title=\"Delete item\" class=\"cross-icon\" src=\"./images/icon-cross.png\" width=\"15\" height=\"15\" alt=\"cross icon\">\r\n        </li>`;\r\n    const Control = new TodoController();\r\n    Control.counterContainer.innerText = Control.counter;\r\n    Control.enableEdit();\r\n    Control.enableDelete();\r\n    Control.changeStatus();\r\n  }\r\n\r\n  // function to get data from local storage and display it to the main page\r\n  displayTodo(state = 'all') {\r\n    const dataContainer = document.querySelector('.todo-list');\r\n    dataContainer.innerHTML = '';\r\n    const todo = new _Todo_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    const data = todo.getTodo(state);\r\n    if (data.length) {\r\n      data.forEach((element) => {\r\n        dataContainer.innerHTML += this.generateElements(element);\r\n      });\r\n      this.counterContainer.innerText = this.counter;\r\n      this.enableEdit();\r\n      this.enableDelete();\r\n      this.changeStatus();\r\n    } else {\r\n      this.counterContainer.innerText = this.counter;\r\n      dataContainer.innerHTML = `\r\n        <li class=\"todo-item px-4\">\r\n            <p class=\"task\">Nothing to show</p>\r\n        </li>`;\r\n    }\r\n  }\r\n\r\n  // function to create corresponding HTML elements for local storage data\r\n  generateElements(item) {\r\n    let elements = '';\r\n    if (item.completed) {\r\n      elements = `\r\n            <li class=\"todo-item px-4 active\" id=\"${item.index}\" >\r\n                <span class=\"check active change-state\"></span>\r\n                <input checked class=\"mark-complete\" type=\"checkbox\" name=\"todo\" value=\"${item.description}\"> \r\n                <p title=\"Double click to edit\" class=\"task\">${item.description}</p>\r\n                <img title=\"Delete item\" class=\"cross-icon\" src=\"./images/icon-cross.png\" width=\"15\" height=\"15\" alt=\"cross icon\">\r\n            </li>`;\r\n    } else {\r\n      elements = `\r\n            <li class=\"todo-item px-4\" id=\"${item.index}\" >\r\n                <span class=\"check change-state\"></span>\r\n                <input class=\"mark-complete\" type=\"checkbox\" name=\"todo\" value=\"${item.description}\">\r\n                <p title=\"Double click to edit\" class=\"task\">${item.description}</p>\r\n                <img title=\"Delete item\" class=\"cross-icon\" src=\"./images/icon-cross.png\" width=\"15\" height=\"15\" alt=\"cross icon\">\r\n            </li>`;\r\n    }\r\n    return elements;\r\n  }\r\n\r\n  // function to listen for double click to edit intended todo item\r\n  enableEdit() {\r\n    const tasks = document.querySelectorAll('.task');\r\n    tasks.forEach((element) => {\r\n      element.addEventListener('dblclick', (e) => {\r\n        const element = e.target;\r\n        element.style.display = 'none';\r\n        const input = element.previousElementSibling;\r\n        input.type = 'text';\r\n        const end = input.value.length;\r\n        input.setSelectionRange(end, end);\r\n        input.focus();\r\n      });\r\n    });\r\n    const markComplete = document.querySelectorAll('.mark-complete');\r\n    markComplete.forEach((element) => {\r\n      element.addEventListener('blur', (e) => {\r\n        const input = e.target;\r\n        const index = input.closest('.todo-item').id;\r\n        const newValue = input.value;\r\n\r\n        const todo = new _Todo_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n        todo.updateTodo(index, newValue);\r\n\r\n        input.nextElementSibling.style.display = 'block';\r\n        input.type = 'checkbox';\r\n        input.nextElementSibling.innerText = newValue;\r\n      });\r\n    });\r\n  }\r\n\r\n  // function to listen for delete icon click to delete intended todo item\r\n  enableDelete() {\r\n    const deleteBtn = document.querySelectorAll('.cross-icon');\r\n    deleteBtn.forEach((element) => {\r\n      element.addEventListener('click', (e) => {\r\n        this.counter -= 1;\r\n        const parent = e.target.closest('.todo-item');\r\n        const todo = new _Todo_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n        todo.deleteTodo(parent.id);\r\n        parent.remove();\r\n        this.displayTodo();\r\n      });\r\n    });\r\n  }\r\n\r\n  // a function to add an event listener to checkbox input to mark todo as completed;\r\n  changeStatus() {\r\n    const todos = document.querySelectorAll('.change-state');\r\n    todos.forEach((element) => {\r\n      element.addEventListener('click', (e) => {\r\n        e.target.classList.toggle('active')\r\n        const index = e.target.closest('.todo-item').id;\r\n        if (e.target.classList.contains('active')) {\r\n          e.target.nextElementSibling.checked = true;\r\n          this.markComplete(index, true);\r\n          this.counter = this.activeCount();\r\n          this.counterContainer.innerText = this.counter;\r\n        } else {\r\n          e.target.nextElementSibling.checked = false;\r\n          this.markComplete(index, false);\r\n          this.counter = this.activeCount();\r\n          this.counterContainer.innerText = this.counter;\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  // function to mark a todo task as complete\r\n  markComplete(index, completed) {\r\n    const todo = new _Todo_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    todo.markComplete(index, completed);\r\n  }\r\n\r\n  // function to get a specific part of data\r\n  getPartOfData() {\r\n    const stage = document.querySelectorAll('.stage-item');\r\n    let activeItem = document.querySelector('.stage-item.active');\r\n    stage.forEach((element) => {\r\n      element.addEventListener('click', (e) => {\r\n        const current = e.currentTarget;\r\n        if (activeItem) {\r\n          activeItem.classList.remove('active');\r\n        }\r\n        activeItem = current;\r\n        current.classList.add('active');\r\n        const part = e.target.getAttribute('data-display');\r\n        this.displayTodo(part);\r\n      });\r\n    });\r\n  }\r\n\r\n  // function to delete all the completed tasks at once\r\n  deleteCompleted() {\r\n    const removeCompleted = document.querySelector('.remove-complete');\r\n    removeCompleted.addEventListener('click', () => {\r\n      const todo = new _Todo_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n      const data = todo.getTodo('active');\r\n      todo.updateLocalStorage(data);\r\n      this.displayTodo();\r\n      this.counterContainer.innerText = this.activeCount();\r\n    });\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://setup-webpack/./src/modules/todoController.js?");

/***/ }),

/***/ "./src/images/bg-desktop-dark.jpg":
/*!****************************************!*\
  !*** ./src/images/bg-desktop-dark.jpg ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"images/bg-desktop-dark.jpg\";\n\n//# sourceURL=webpack://setup-webpack/./src/images/bg-desktop-dark.jpg?");

/***/ }),

/***/ "./src/images/bg-desktop-light.jpg":
/*!*****************************************!*\
  !*** ./src/images/bg-desktop-light.jpg ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"images/bg-desktop-light.jpg\";\n\n//# sourceURL=webpack://setup-webpack/./src/images/bg-desktop-light.jpg?");

/***/ }),

/***/ "./src/images/bg-mobile-dark.jpg":
/*!***************************************!*\
  !*** ./src/images/bg-mobile-dark.jpg ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"images/bg-mobile-dark.jpg\";\n\n//# sourceURL=webpack://setup-webpack/./src/images/bg-mobile-dark.jpg?");

/***/ }),

/***/ "./src/images/bg-mobile-light.jpg":
/*!****************************************!*\
  !*** ./src/images/bg-mobile-light.jpg ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"images/bg-mobile-light.jpg\";\n\n//# sourceURL=webpack://setup-webpack/./src/images/bg-mobile-light.jpg?");

/***/ }),

/***/ "./src/images/icon-check.png":
/*!***********************************!*\
  !*** ./src/images/icon-check.png ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"images/icon-check.png\";\n\n//# sourceURL=webpack://setup-webpack/./src/images/icon-check.png?");

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ var __webpack_exports__ = (__webpack_exec__("./src/index.js"));
/******/ }
]);